# TCP三次握手与四次挥手

## TCP连接的建立（三次握手）

<div align=center><img src=Pictures/三次握手.gif></div>

最开始的时候客户端和服务器都是处于CLOSED状态。主动打开连接的为客户端，被动打开连接的是服务器。

在三次握手建立连接的阶段，是不会传输TCP报文段的，传输的是`传输控制块（TCB）`，**传输控制块TCB(`Transmission Control Block`)**<font color=red>存储了每一个连接中的一些重要信息</font>，如：TCP连接表，指向发送和接收缓存的指针，指向重传队列的指针，当前的发送和接收序号等等。

- TCP`服务器进程`先创建`传输控制块TCB`，时刻准备接受客户进程的连接请求，此时服务器就进入了`LISTEN`（监听）状态；

- TCP`客户进程`也是先创建`传输控制块TCB[SYN=1, seq=x]`，然后向服务器发出`连接请求报文`，这时报文首部中的**同步位**`SYN=1`，同时选择一个`初始序列号seq=x`，此时，TCP客户端进程进入了`SYN-SENT（同步已发送状态）`状态。TCP规定，<font color=red>SYN报文段（SYN=1的报文段）不能携带数据，但需要消耗掉一个序号</font>。

- TCP`服务器`收到请求报文后，如果同意连接，则构建好`TCB[SYN=1, seq=y, ACK=1, ack=x+1]`发出`确认报文`。确认报文中应该ACK=1，SYN=1，`确认号`是ack=x+1，同时也要为自己初始化一个序列号seq=y，此时，TCP服务器进程进入了`SYN-RCVD（同步收到）`状态。<font color=red>这个报文也不能携带数据，但是同样要消耗一个序号</font>。

- TCP`客户进程`收到确认后，还要向服务器给出确认。确认报文的`ACK=1`，`ack=y+1`，自己的序列号`seq=x+1`，此时，TCP连接建立，客户端进入`ESTABLISHED（已建立连接）`状态。TCP规定，<font color=red>ACK报文段可以携带数据，但是如果不携带数据则不消耗序号</font>。

- 当`服务器`收到客户端的确认后也进入`ESTABLISHED`状态，此后双方就可以开始通信了。

<div align=center><img src=Pictures/三次握手.jpg></div>


### 《自顶向下》解释三次握手

<div align=center><img src=Pictures/三次握手1.jpg></div>

- 第一步：客户端向服务器端发送包含了一个随机初始序号(`client_isn`)的**SYN报文段**。
  客户端的TCP首先向服务器端的TCP发送一个特殊的TCP报文段，该报文段中不包含应用层数据，但在报文段的首部中的一个标志位(`SYN比特`)被置为1。因此这个特殊报文段被称为**SYN报文段**。
  客户会随机地选择一个初始序号(`client_isn`)，并将此编号放置于该起始的TCP SYN报文段的序号字段中。
  该报文段会被封装在一个IP数据报中，并发送给服务器。

- 第二步：服务器端接受到数据报后，向客户端发送**SYNACK报文段**(SYNACK segment)
  服务器从接收到的数据报中提取出TCP SYN报文段，为该TCP连接分配TCP缓存和变量，并向该客户TCP发送允许连接的报文段。
  在报文段的首部包含3个重要信息：SYN比特被置为1；**确认号**字段`ack`被置为`client_isn + 1`；服务器选择自己的初始序号(`server_isn`)。
  我收到了你发起建立连接的SYN分组，该分组带有初始序号`client_isn`。我同意建立该连接，我自己的初始序号为`server_isn`。

- 第三步：收到SYNACK报文段后，客户端向服务器端发送报文段，**对服务器的允许连接的报文段进行确认**。
  **确认号**字段`ack`被置为`server_isn + 1`，初始序号被置为`client_isn + 1`。因为连接已经建立了，所以SYN比特被置为0。

一旦完成这3个步骤，客户和服务器主机就可以相互发送包括数据的报文段了。在以后每一个报文段中，SYN比特都将被置为0。 



### 问题

- 为何不直接在第一次握手就带上报文段消息，非要第三次才可以带？

    因为<font color=red>TCP是要保证数据的不丢失且可靠</font>，如果在第一次就带上报文段消息，此次建立连接很有可能就会失败，那么就**不能保证数据的不丢失**了，在不可靠的机制上进行这种操作，换来的代价太大，每次发送报文段的资源也会增大，得不偿失；

    而**第三次握手的时候，客户端已经知道服务器端准备好了**，所以只要告诉服务器端自己准备好了就okay了，所以此时带上报文段信息没有任何问题。

- 可不可以只握手两次？

    不可以，主要<font color=red>防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误</font>。
    
    三次握手主要是解决这样一个常见的问题，客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了，由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时**重新向服务器发送这条报文**，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。此时<font color=red>此前滞留的那一次请求连接，网络通畅了到达了服务器，**这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接**，这将导致不必要的错误和资源的浪费</font>。

    如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是**客户端不会再次发出确认**。<font color=red>由于**服务器收不到确认**，就知道客户端并没有请求连接</font>。


## TCP连接的释放（四次挥手）

<div align=center><img src=Pictures/四次挥手.gif></div>

数据传输完毕后，双方都可释放连接。最开始的时候，客户端和服务器都是处于`ESTABLISHED`状态，然后客户端主动关闭，服务器被动关闭。

1.  `客户端进程`发出**连接释放报文**，<font color=red>告诉服务器端，客户端需要关闭了</font>，并且停止发送数据。释放数据报文首部，`FIN=1`，其**序列号**为`seq=u`（<font color=red>等于前面已经传送过来的数据的最后一个字节的序号加1</font>），此时，客户端进入`FIN-WAIT-1`（**终止等待1**）状态。 TCP规定，<font color=red>`FIN报文段`即使不携带数据，也要消耗一个序号</font>。

2. `服务器`收到连接释放报文，发出`确认报文`，<font color=red>告诉客户端收到了客户端要关闭的消息了</font>，`ACK=1`，`ack=u+1`，并且带上自己的序列号`seq=v`，此时，服务端就进入了`CLOSE-WAIT`（关闭等待）状态。<font color=red>TCP服务器通知高层的应用进程，进程需要关闭连接了</font>，这时候处于`半关闭状态`，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个`CLOSE-WAIT`状态持续的时间。

3. `客户端`收到服务器的确认请求后，此时，客户端就进入`FIN-WAIT-2`（**终止等待2**）状态，等待服务器发送`连接释放报文`（在这之前还需要接受<font color=red>服务器发送的最后的数据</font>）。

4. `服务器`将<font color=red>最后的数据</font>发送完毕后，就向客户端发送`连接释放报文`，<font color=red>告知客户端，服务器端现在要关闭了</font>，`FIN=1`，`ack=u+1`，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为`seq=w`，此时，服务器就进入了`LAST-ACK`（最后确认）状态，等待客户端的确认。

5. `客户端`收到服务器的连接释放报文后，必须`发出确认`，<font color=red>告知服务器端，客户端已经知道了你准备好关闭了</font>，`ACK=1`，`ack=w+1`，而自己的序列号是`seq=u+1`，此时，客户端就进入了`TIME-WAIT`（时间等待）状态。注意此时TCP连接还没有释放，必须经过`2*MSL`（最长报文段寿命——最长报文段传输时间）的时间后，当客户端`撤销相应的TCB`后，才进入`CLOSED`状态。
  
6. `服务器`只要收到了客户端发出的确认，立即进入`CLOSED`状态。同样，`撤销TCB`后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。


<div align=center><img src=Pictures/四次挥手.jpg></div>

### 问题

1. 为何不能三次挥手呢？
    首先如果去掉最后一次挥手，那么服务器端就不知道自己要关闭的报文有没有传输成功，可能半路上就失败了，但是此时客户端不知道，导致客户端一直在等待服务器关闭，但是此时服务器端直接就关闭了；
    
    如果中间的两次挥手合并，那是肯定不行的，因为此时服务器端可能还有很多报文未处理完，此时直接关闭肯定会对传输有很大影响。

2. 为什么客户端在收到服务器端发来的FIN包后要等2个最长报文段传输时间？
   防止最后自己发去的`ack`没传送到服务器，如果服务器没收到客户端的`ack`，肯定会选择重发一次`FIN`包，那么此时如果客户端已经关闭了，客户端就不能再发`ack`确认收到了。至于为何是2个报文段传输时间，因为刚好一去一回嘛… 2个最长报文传输时间没有FIN包发来，就说明服务器已经关闭了，客户端也就可以安心关闭了。

3. 为什么建立连接是三次握手，关闭连接确是四次挥手呢？
    建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。

    而关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送，从而导致多了一次。

4. 如果已经建立了连接，但是客户端突然出现故障了怎么办？
    TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。


## TCP状态

客户端TCP状态：
<div align=center><img src=Pictures/客户端TCP状态.jpg></div>

客户中的TCP向服务器中的TCP发送一个**SYN报文段**。在发送过SYN报文段后，客户TCP进入了**SYN_SENT状态**。 当客户TCP处在SYN_SENf状态时，它**等待来自服务器TCP的对客户所发报文段进行确认且SYN比特被置为1的一个报文段**。收到这样一个报文段之后，客户TCP进入**ESTABIJSHED**(已建立)状态。当处在ESTABIJSHED状态时，TCP客户就能发送和接收包含有效载荷数据(即应用层产生的数据)的TCP报文段了。

客户应用程序决定要关闭该连接，客户TCP发送一个带有FIN比特被置为1的TCP报文段，并进入**FIN_WAIT_1**状态。当处在FIN_WAIT_l状态时，客户TCP等待一个来自服务器的带有确认的TCP报文段。当它收到该报文段时，客户TCP进入**FIN_WAIT_2**状态。 当处在FIN_WAIT_2状态时，客户等待 来自服务器的FIN比特被置为1的另一个报文段；当收到该报文段后，客户TCP对服务器的报文段进行确认，并进入**TIME_WAIT**状态。假定ACK丢失，TIME_WAIT状态使TCP客户重传最后的确认报文。在TIME_WAIT状态中所消耗的时间是与具体实现有关的，而典型的值是30秒、1分钟或2分钟。经过等待后，连接就正式关闭，客户端所有资源（包括端口号）将被释放。

服务器端TCP状态：
<div align=center><img src=Pictures/服务器端TCP状态.jpg></div>




# HTTP与HTTPS

HTTP协议全称`Hyper Text Transfer Protocol`超文本传输协议，位于TCP/IP四层模型当中的应用层。

应用层(HTTP/FTP)；传输层(TCP/UDP)；网络层(IP/ARP)。



## 什么是HTTP

**超文本传输协议**(HyperText Transfer Protocol)，是一个基于**请求与响应**，**无状态**的，**应用层**的协议，常基于TCP/IP协议传输数据，互联网上应用最为广泛的一种网络协议。设计HTTP的初衷是为了**提供一种发布和接收HTML页面的方法**。


下图是Akamai公司建立的一个官方的演示，使用`HTTP/1.1`(1997年)和`HTTP/2`(2015年)同时请求379张图片，观察请求的时间，明显看出`HTTP/2`性能占优势：

<div align=center><img src=Pictures\Http1.1VS2.jpg></div>

`HTTP/2`采用**多路复用**技术：通过**单一的`HTTP/2`连接请求**发起**多重的请求-响应消息**，**多个请求stream共享一个TCP连接**，实现**多流并行**而**不是依赖建立多个TCP连接**。

### 常用的HTTP方法

- GET：用于**请求访问**已经被URI（Uniform Resource Identifier——统一资源标识符——表示的是web上每一种**可用的资源**，如 HTML文档、图像、视频片段、程序等）识别的资源，可以通过URL（Uniform Resource Locator——统一资源定位符）传参给服务器；
- POST：用于**传输信息给服务器**，主要功能与GET方法类似，但一般推荐使用POST方式。
- PUT：传输文件，报文主体中包含文件内容，保存到对应URI位置。
- HEAD：获得报文首部，与GET方法类似，只是不返回报文主体，一般用于验证URI是否有效。
- DELETE：删除文件，与PUT方法相反，删除对应URI位置的文件。
- OPTIONS：查询相应URI支持的HTTP方法。

### GET方法与POST方法的区别

- GET重点在从服务器上获取资源，POST重点在向服务器发送数据；
- GET传输数据是**通过URL请求**，以`field（字段）= value`的形式，置于URL后，并用"?"连接，多个请求数据间用"&"连接，如`http://127.0.0.1/Test/login.action?name=admin&password=admin`，这个过程**用户是可见**的；
    POST传输数据通过HTTP的POST机制，**将字段与对应值封存在请求实体中**发送给服务器，这个过程**对用户是不可见的**；
- GET方式只能支持ASCII字符，向服务器传的中文字符可能会乱码。
POST支持标准字符集，可以正确传递中文字符。

### HTTP请求报文与响应报文格式

请求报文包含三部分：
a、请求行：包含请求方法、URL、HTTP版本信息
b、请求首部字段
c、请求内容实体
响应报文包含三部分：
a、状态行：包含HTTP版本、状态码、状态码的原因短语
b、响应首部字段
c、响应内容实体

<div align=center><img src=Pictures\请求报文与响应报文.png></div>

### 常见的HTTP相应状态码
200：请求被正常处理
404：服务器无法找到对应资源
500：服务器内部错误


### 在浏览器输入网址后发生了什么

“天龙八部”：

客户端输入URL回车，**DNS(Domain Name System)解析域名**得到服务器的IP地址，服务器在80**端口**监听客户端请求，端口通过**TCP/IP协议**建立连接。

**第一步：浏览器查找该域名的IP地址——DNS域名解析**

浏览器把域名发送给系统默认DNS服务器。如果该服务器本地有缓存，且缓存未过期，则直接返回结果否则向上一级DNS服务器查询，直到DNS根服务器。

**第二步：通过三次握手，建立了客户端和服务器之间的TCP连接：**

**第三步：浏览器根据解析得到的IP地址向web服务器发送一个HTTP请求**

浏览器知道了网址的对应服务器IP地址和端口，然后就通过TCP协议发起网络请求。

**第四步：服务器收到请求并进行处理**

**第五步：服务器返回一个响应**

**第六步：浏览器对该响应进行解码，渲染显示**

**第七步：页面显示完成后，浏览器发送异步请求。**

页面显示完成后客户端仍与服务器端保持着联系。它会持续与服务器保持联系来及时更新一些页面信息。

**第八步：关闭TCP连接**


## 什么是HTTPS

HTTPS是**身披SSL外壳的HTTP**。HTTPS是一种通过计算机网络进行**安全通信**的传输协议，**经由HTTP进行通信，利用SSL/TLS(TLS是传输层加密协议，前身是SSL协议)建立全信道，加密数据包**。HTTPS使用的主要目的是**提供对网站服务器的身份认证**，同时**保护交换数据的隐私与完整性**。


## Http与Https比较

HTTP特点：
- 无状态：HTTP服务器不保存关于客户的任何信息。
    比如**访问一个网站需要反复进行登录操作**。
- 无连接：HTTP/1.1之前，由于无状态特点，每次请求需要通过TCP三次握手四次挥手，和服务器重新建立连接。
    比如某个客户机在短时间多次请求同一个资源，服务器并不能区别是否已经响应过用户的请求，所以每次需要重新响应请求，需要耗费不必要的时间和流量。
- 基于请求和响应：由客户端发起请求，服务端响应
- **不安全**：通信使用**明文**、请求和响应不会对通信方进行确认、无法保护数据的完整性。

针对无状态的解决策略：
- 通过Cookie/Session技术
- HTTP/1.1**持久连接**（HTTP **keep-alive**）方法，只要任意一端没有明确提出断开连接，则保持TCP连接状态，在请求首部字段中的`Connection: keep-alive`即为表明使用了持久连接。

HTTPS特点：
基于HTTP协议，通过SSL或TLS提供**加密**处理数据（采用混合加密技术，中间者无法直接查看明文内容）、**验证对方身份**（通过证书认证客户端访问的是自己的服务器）以及**数据完整性保护**（防止传输的内容被中间人冒充或者篡改）。

### HTTPS如何加密？

小灰和小红可以事先约定一种**对称加密方式**，并且**约定一个随机生成的密钥**。**后续的通信中**，信息发送方都使用密钥对信息加密，而信息接收方通过同样的密钥对信息解密。

虽然我们在后续的通信中对明文进行了加密，但是**第一次约定加密方式和密钥的通信仍然是明文**，如果第一次通信就已经被拦截了，那么密钥就会泄露给中间人，中间人仍然可以解密后续所有的通信内容。

可以使用**非对称加密**，为密钥的传输做一层额外的保护。

非对称加密的一组秘钥对中，包含一个**公钥**和一个**私钥**。**明文既可以用公钥加密，用私钥解密；也可以用私钥加密，用公钥解密**。

在小灰和小红建立通信的时候，小红首先把自己的**公钥**Key1发给小灰；收到小红的公钥以后，**小灰自己生成一个用于对称加密的密钥Key2**，并且用刚才接收的公钥Key1对Key2进行加密，发送给小红；**小红利用自己非对称加密的私钥**，解开了公钥Key1的加密，获得了Key2的内容。**从此以后，两人就可以利用Key2进行对称加密的通信了**。在通信过程中，即使中间人在一开始就截获了公钥Key1，由于不知道私钥是什么，也无从解密。

中间人虽然不知道小红的私钥是什么，但是在截获了小红的公钥Key1之后，却可以偷天换日，**自己另外生成一对公钥私钥，把自己的公钥Key3发送给小灰**。

小灰不知道公钥被偷偷换过，以为Key3就是小红的公钥。于是按照先前的流程，用Key3加密了自己生成的对称加密密钥Key2，发送给小红。这一次通信再次被中间人截获，中间人先用自己的私钥解开了Key3的加密，获得Key2，然后再用当初小红发来的Key1重新加密，再发给小红。这样一来，两个人后续的通信尽管用Key2做了对称加密，但是中间人已经掌握了Key2，所以可以轻松进行解密。


有必要引入第三方，一个权威的证书颁发机构（CA）来解决：

- 作为**服务端的小红**，首先把自己的公钥Key1发给证书颁发机构，向证书颁发机构申请证书。
- 证书颁发机构自己也有**一对公钥私钥**。**机构利用自己的私钥来加密Key1，并且通过服务端网址等信息生成一个证书签名，证书签名同样经过机构的私钥加密**。证书制作完成后，机构把证书发送给了**服务端小红**。
- 当小灰向小红请求通信的时候，小红不再直接返回自己的公钥，而是**把自己申请的证书返回给小灰**。
- 小灰收到证书以后，要做的第一件事情是**验证证书的真伪**。需要说明的是，**各大浏览器和操作系统已经维护了所有权威证书机构的名称和公钥**。所以小灰只需要知道是哪个机构颁布的证书，就可以**从本地找到对应的机构公钥，解密出证书签名**。
- 接下来，**小灰按照同样的签名规则，自己也生成一个证书签名，如果两个签名一致，说明证书是有效的**。验证成功后，小灰就可以放心地再次**利用机构公钥，解密出服务端小红的公钥Key1**。
- 像之前一样，小灰生成自己的对称加密密钥Key2，并且**用服务端公钥Key1加密Key2**，发送给小红。
- 最后，小红用自己的私钥解开加密，得到对称加密密钥Key2。于是**两人开始用Key2进行对称加密的通信**。

中间人是否可以自己也向权威机构申请一个证书，并且把小红发来的证书偷偷换成自己的证书呢？

没有用！因为**证书的签名是由服务端网址等信息生成的，并且经过机构私钥加密**，中间人也无法篡改！




# DNS：因特网的目录服务

识别主机有两种方式，通过**主机名**或者**TP地址**。人们喜欢便于记忆的主机名标识方式，而路由器则喜欢定长的、有着层次结构的IP地址。为了折衷这些不同的偏好，我们需要一种能进行**主机名到IP 地址转换的目录服务**。这就是**域名系统**(Domain Name System, DNS)的主要任务。

一个域名往往对应多个DNS地址：
<div align=center><img src=Pictures\一个域名对应多个DNS.jpg width=80%></div>

[浏览器中输入网址到返回页面的全过程](#在浏览器输入网址后发生了什么)

## DNS解析

<div align=center><img src=Pictures\DNS解析.jpg></div>


浏览器输入地址，然后浏览器这个进程去调操作系统某个库里的`gethostbyname`函数(例如，Linux GNU glibc标准库的gethostbyname函数)，然后呢这个**函数通过网卡给DNS服务器发UDP请求**，接收结果，然后将结果给返回给浏览器。

我们在用chrome浏览器的时候，其实会先去**浏览器的DNS缓存**里头查询，DNS缓存中没有，再去调用gethostbyname函数；gethostbyname函数在试图进行DNS解析之前**首先检查域名是否在本地Hosts**里，如果没找到再去DNS服务器上查。


### DNS在域名解析上用UDP

DNS中也有一个地方用到了TCP协议。那就是区域传送！

DNS的规范规定了2种类型的DNS服务器，一个叫**主DNS服务器**，一个叫**辅助DNS服务器**。在一个区中主DNS服务器从自己本机的数据文件中读取该区的DNS数据信息，而辅助DNS服务器则从区的主DNS服务器中读取该区的DNS数据信息。当一个辅助DNS服务器启动时，它需要与主DNS服务器通信，并加载数据信息，这就叫做区传送(zone transfer)。这种情况下，使用TCP协议。

这里之所以用TCP是因为从主DNS上复制内容，需要保证**可靠性**；并且TCP协议传输的**内容大**(UDP协议最大只能传512字节)！


### DNS如何做域名解析

<div align=center><img src=Pictures\DNS服务器的层次结构.jpg></div>

`www.tmall.com`对应的真正的域名为`www.tmall.com.`。末尾的`.`称为**根域名**，因为每个域名都有根域名，因此通常省略。

根域名的下一级，叫做**顶级域名**（top-level domain，缩写为TLD），比如`.com`、`.net`；

再下一级叫做**次级域名**（second-level domain，缩写为SLD），比如`www.tmall.com`里面的`.tmall`，这一级域名是用户可以注册的；

再下一级是**主机名**（host），比如`www.tmall.com`里面的`www`，又称为**三级域名**，这是用户在自己的域里面为服务器分配的名称，是用户可以任意分配的。

那么解析流程就是分级查询！

- 先在本机的DNS里头查，如果有就直接返回了；
- 本机DNS里头发现没有，就去根服务器里查。根服务器发现这个域名是属于`com`域，因此根域DNS服务器会返回它所管理的`com`域中的DNS服务器的IP地址，意思是**虽然我不知道你要查的那个域名的地址，但你可以去`com`域问问看**；
- 本机的DNS接到又会向`com`域的DNS服务器发送查询消息。`com`域中也没有`www.tmall.com`这个域名的信息，和刚才一样，`com`域服务器会返回它下面的`tmall.com`域的DNS服务器的IP地址。

以此类推，只要重复前面的步骤，就可以顺藤摸瓜找到目标DNS服务器。


# TCP与UDP


