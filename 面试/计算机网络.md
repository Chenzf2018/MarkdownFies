参考资料：
https://www.jianshu.com/p/7767d5d8e648

# 计算机网络体系结构

计算机网络体系结构分为3种：OSI体系结构、TCP / IP体系结构、五层体系结构

- OSI体系结构：概念清楚且理念完整，但复杂且不实用
- TCP/IP体系结构：含了一系列构成互联网基础的网络协议，是Internet的核心协议，被广泛应用于局域网和广域网
- 五层体系结构：融合了OSI与TCP/IP的体系结构，目的是为了学习与讲解计算机原理

<div align=center><img src=Pictures/计算机网络体系结构.webp></div>

其中TCP/IP体系结构较为广泛：

<div align=center><img src=Pictures/TCP_IP体系结构.webp></div>

OSI的体系结构详细介绍：

<div align=center><img src=Pictures\OSI的体系结构.png></div>

<div align=center><img src=Pictures\协议.jpg></div>


# HTTP与HTTPS

HTTP协议全称`Hyper Text Transfer Protocol`超文本传输协议，位于TCP/IP四层模型当中的应用层。

应用层(HTTP/FTP)；传输层(TCP/UDP)；网络层(IP/ARP)。



## 什么是HTTP

<div align=center><img src=Pictures/HTTP.jpg></div>

**超文本传输协议**(HyperText Transfer Protocol)，是一个基于**请求与响应**，**无状态**的**应用层**协议，**采用TCP作为运输层协议，因此传输可靠性高**，互联网上应用最为广泛的一种网络协议。设计HTTP的初衷是为了**提供一种发布和接收HTML页面的方法**。

### 常用的HTTP方法

- GET：用于**请求访问已经被URI**（Uniform Resource Identifier——统一资源标识符——表示的是web上每一种**可用的资源**，如 HTML文档、图像、视频片段、程序等）**识别的资源**，可以通过URL（Uniform Resource Locator——统一资源定位符）**传参给服务器**；
- POST：用于**传输信息给服务器**，主要功能与GET方法类似，但一般推荐使用POST方式。
- PUT：传输文件，报文主体中包含文件内容，保存到对应URI位置。
- HEAD：获得报文首部，与GET方法类似，只是不返回报文主体，一般用于验证URI是否有效。
- DELETE：删除文件，与PUT方法相反，删除对应URI位置的文件。
- OPTIONS：查询相应URI支持的HTTP方法。

**GET方法与POST方法的区别：**

- GET重点在从服务器上获取资源，POST重点在向服务器发送数据；
- GET传输数据是**通过URL请求**，以`field（字段）= value`的形式，置于URL后，并用"?"连接，多个请求数据间用"&"连接，如`http://127.0.0.1/Test/login.action?name=admin&password=admin`，这个过程**用户是可见**的；
    POST传输数据通过HTTP的POST机制，**将字段与对应值封存在请求实体中**发送给服务器，这个过程**对用户是不可见的**；
- GET方式只能支持ASCII字符，向服务器传的中文字符可能会乱码。
POST支持标准字符集，可以正确传递中文字符。

<div align=center><img src=Pictures\GET_POST区别.webp></div>

GET和POST本质都是HTTP请求，只不过对它们的作用做了界定和适配，并且让他们适应各自的场景。

- 本质区别：GET只是**一次HTTP请求**，POST先发请求头再发请求体，实际上是**两次请求**。

- 从功能上讲，GET一般用来从服务器上获取资源，POST一般用来**更新服务器上的资源**；

- 从REST服务角度上说，GET是幂等的，即**读取同一个资源，总是得到相同的数据**；而POST不是幂等的，因为每次请求对资源的改变并不是相同的；进一步地，GET不会改变服务器上的资源，而POST会对服务器资源进行改变；

- 从请求参数形式上看，GET请求的数据会附在URL之后，即将请求数据放置在HTTP报文的请求头中，以?分割URL和传输数据，参数之间以&相连。特别地，如果数据是英文字母/数字，原样发送；否则，会将其编码为`application/x-www-form-urlencoded MIME`字符串(如果是空格，转换为+，如果是**中文/其他字符**，则直接把字符串用BASE64加密，得出如：`%E4%BD%A0%E5%A5%BD`，其中`%XX`中的XX为该符号以16进制表示的ASCII)；而POST请求会把提交的数据则放置在是HTTP请求报文的请求体 中；

- 就安全性而言，POST的安全性要比GET的安全性高，因为GET请求提交的数据将明文出现在URL上，而且POST请求参数则**被包装到请求体中**，相对更安全；

- 从请求的大小看，GET请求的长度受限于浏览器或服务器对URL长度的限制，允许发送的数据量比较小，而**POST请求则是没有大小限制的**。



HTTP协议采用**请求/响应**的工作方式：

<div align=center><img src=Pictures\HTTP工作方式.webp></div>

### HTTP请求报文

HTTP的请求报文由`请求行、请求头和请求体`组成：

<div align=center><img src=Pictures\HTTP请求报文.webp></div>
<div align=center><img src=Pictures\HTTP请求报文.png></div>

**请求行：**

- 作用
  声明`请求方法、主机域名、资源路径和协议版本`
- 结构
  请求行的组成：`请求方法 + 请求路径 + 协议版本`

注：空格不能省

<div align=center><img src=Pictures\HTTP请求行组成.webp></div>

假设：请求报文采用GET方法，URL地址为`http://www.tsinghua.edu.cn/chn/yxsz/index.htm`且使用HTTP1.1版本，则请求行是：`GET /chn/yxsz/index.htm HTTP/1.1`。

**请求头：**

- 作用：声明客户端、服务器/报文的部分信息
- 使用方式：采用`header(字段名)：value(值)`的方式

<div align=center><img src=Pictures\常见请求Header.webp width=80%></div>

举例：(URL地址：`http://www.tsinghua.edu.cn/chn/yxsz/index.htm`）
Host：www.tsinghua.edu.cn (表示主机域名）
User - Agent：Mozilla/5.0 (表示用户代理是使用Netscape浏览器）


**请求体：**

作用：存放**需发送给服务器的数据信息**。它是可选部分，如**GET请求就无请求数据**。

<div align=center><img src=Pictures\HTTP请求体.webp></div>


**关于请求报文的总结如下：**

<div align=center><img src=Pictures\HTTP请求报文1.webp></div>

**HTTP请求报文示例：**

<div align=center><img src=Pictures\HTTP请求报文示例.webp></div>


### HTTP响应报文

HTTP的响应报文包括：**状态行、响应头和响应体**

<div align=center><img src=Pictures\HTTP响应报文.jpg></div>

状态行：声明协议版本，状态码和状态描述；
响应头：声明客户端、服务器/报文的部分信息
响应体：存放需要发送的数据信息

<div align=center><img src=Pictures\HTTP响应报文.png></div>




**状态行：**

- 作用
  声明 协议版本，状态码，状态码描述
- 组成
  状态行有协议版本、状态码和状态信息组成
  
其中，空格不能省

<div align=center><img src=Pictures\HTTP响应报文状态行.webp></div>

**常见的HTTP相应状态码：**

状态码用以表示**网页服务器HTTP响应状态**的3位数字代码

200：请求被正常处理
404：服务器无法找到对应资源
500：服务器内部错误

| 状态码 |                        描述                        |
|:------:|:--------------------------------------------------:|
|   1xx  | 提示信息，请求被成功接收（中间状态，一般观察不到） |
|   2xx  |           成功，请求被成功处理（**200 ok**）           |
|   3xx  |               重定向相关（304 缓存）               |
|   4xx  |           客户端错误（**404 资源路径有误**）           |
|   5xx  |            服务器端错误（**500 程序有错**）            |

**响应头：**

- 作用：声明客户端、服务器 / 报文的部分信息
- 使用方式：采用`header(字段名):value(值)`的方式

<div align=center><img src=Pictures\HTTP响应报文响应头.webp width=70%></div>

**响应体：**

- 作用：存放需返回给客户端的数据信息
- 使用方式：和请求体是一致的，同样分为：任意类型的数据交换格式、键值对形式和分部分形式

<div align=center><img src=Pictures\HTTP响应报文响应体.webp></div>

**总结：**

<div align=center><img src=Pictures\HTTP响应报文总结.webp></div>


### 在浏览器输入网址后发生了什么

<div align=center><img src=Pictures\打开一个网页的过程.webp></div>

“天龙八部”：

客户端输入URL回车，**DNS(Domain Name System)解析域名**得到服务器的IP地址，服务器在80**端口**监听客户端请求，端口通过**TCP/IP协议**建立连接。

**第一步：浏览器查找该域名的IP地址——DNS域名解析**

浏览器把域名发送给系统默认DNS服务器。如果该服务器本地有缓存，且缓存未过期，则直接返回结果否则向上一级DNS服务器查询，直到DNS根服务器。

**第二步：通过三次握手，建立了客户端和服务器之间的TCP连接：**

**第三步：浏览器根据解析得到的IP地址向web服务器发送一个HTTP请求**

浏览器知道了网址的对应服务器IP地址和端口，然后就通过TCP协议发起网络请求。

**第四步：服务器收到请求并进行处理**

**第五步：服务器返回一个响应**

**第六步：浏览器对该响应进行解码，渲染显示**

**第七步：页面显示完成后，浏览器发送异步请求。**

页面显示完成后客户端仍与服务器端保持着联系。它会持续与服务器保持联系来及时更新一些页面信息。

**第八步：关闭TCP连接**


### HTTP1.1 与 HTTP1.0的区别

| 版本  | 产生时间  |  内容 | 发展现状  |
|---|---|---|---|
| HTTP/0.9	 | 1991年  | 不涉及数据包传输，规定客户端和服务器之间通信格式，只能GET请求  |  没有作为正式的标准 |
| HTTP/1.0  | 1996年  | 传输内容格式不限制，增加PUT、PATCH、HEAD、 OPTIONS、DELETE命令  | 正式作为标准  |
| HTTP/1.1  | 1997年  | **持久连接(长连接)**、节约带宽、HOST域、管道机制、分块传输编码  |2015年前使用最广泛   |
| HTTP/2  | 2015年  | **多路复用**、服务器推送、头信息压缩、二进制协议等  | 逐渐覆盖市场  |

Http1.1 比 Http1.0 多了以下优点：

- 引入**持久连接**，即**在同一个TCP的连接中可传送多个HTTP请求与响应**
- 多个请求与响应可同时进行、可重叠
- 引入更加多的请求头与响应头
  如与身份认证、状态管理和Cache缓存等机制相关的、HTTP1.0无host字段

在HTTP/1.0 中默认使用**短连接**。也就是说，**客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接**。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如：JavaScript 文件、图像文件、CSS 文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。

而从HTTP/1.1起，默认使用**长连接**，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码`Connection:keep-alive`。

在使用长连接的情况下，**当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭**，客户端再次访问这个服务器时，会**继续使用这一条已经建立的连接**。

`Keep-Alive`不会永久保持连接，它有一个**保持时间**，可以在不同的服务器软件（如：Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。




#### HTTP处理长连接的方式

<div align=center><img src=Pictures\HTTP处理长连接.jpg></div>

#### HTTP2

下图是Akamai公司建立的一个官方的演示，使用`HTTP/1.1`(1997年)和`HTTP/2`(2015年)同时请求379张图片，观察请求的时间，明显看出`HTTP/2`性能占优势：

<div align=center><img src=Pictures\Http1.1VS2.jpg></div>

`HTTP/2`采用**多路复用**技术：通过**单一的`HTTP/2`连接请求**发起**多重的请求-响应消息**，**多个请求stream共享一个TCP连接**，实现**多流并行**而**不是依赖建立多个TCP连接**。

HTTP2.0 的主要变化：

- HTTP2.0支持**多路复用**，**同一个连接可以并发处理多个请求**，方法是**把HTTP数据包拆为多个帧，并发有序的发送，根据序号在另一端进行重组，而不需要一个个HTTP请求顺序到达**；

- HTTP2.0支持**服务端推送**，就是服务端在HTTP请求到达后，除了返回数据之外，还推送了额外的内容给客户端；

- HTTP2.0**压缩了请求头**，同时基本单位是**二进制帧流**，这样的数据占用空间更少；

- HTTP2.0适用于HTTPS场景，因为其在HTTP和TCP中间加了一层SSL层。





## 什么是HTTPS

HTTPS是**身披SSL外壳的HTTP**。HTTPS是一种通过计算机网络进行**安全通信**的传输协议，**经由HTTP进行通信，利用SSL/TLS(TLS是传输层加密协议，前身是SSL协议(安全套接字层))建立全信道，加密数据包**。HTTPS使用的主要目的是**提供对网站服务器的身份认证**，同时**保护交换数据的隐私与完整性**。


### HTTP与HTTPS比较

**HTTP特点：**
- 无状态：HTTP服务器不保存关于客户的任何信息。
    - 比如**访问一个网站需要反复进行登录操作**。
    - HTTP 是无状态的意思就是说**对于同一客户端的每一次请求服务器的处理都是一样的**，不会记录客户端的上一次访问，也不记得客户端访问过多少次，因此使得**服务器更能支持大量的并发操作**。
- 无连接：HTTP/1.1之前，由于无状态特点，每次请求需要通过TCP三次握手四次挥手，和服务器重新建立连接。
    - 比如某个客户机在短时间多次请求同一个资源，服务器并不能区别是否已经响应过用户的请求，所以每次需要重新响应请求，需要耗费不必要的时间和流量。
    - 虽然HTTP是无连接，但是TCP是面向连接的，所以客户端发起一个请求的时候还是要先建立连接，然后再进行HTTP通信，最后再断开连接。在HTTP协议1.0版本和之前的时候，HTTP都是属于这种**非持续连接**的方式，即每个请求访问都需要建立连接，释放连接，即使在同一个页面下也是如此，这是因为一个页面通常存在多个请求。非持续的连接不仅会增加了服务器的负担而且对于同一个界面的响应速度也会降低。
    - HTTP 1.1 版本使用了**持续连接**，持续连接就是客户端和服务器在建立连接后进行通信后，仍然在一段时间内保持连接，这样客户端和服务器后续的请求就不用再进行建立释放的操作。而且持续连接还可以进行非流水线的方式进行通信，就是下一次的客户端请求不用等上一次的服务器的答复就能发送，使得客户端的访问更加高效快速。
- 基于请求和响应：由客户端发起请求，服务端响应
- **不安全**：通信使用**明文**、请求和响应不会对通信方进行确认、无法保护数据的完整性。

针对无状态的解决策略：
- 通过Cookie/Session技术
- HTTP/1.1**持久连接**（HTTP **keep-alive**）方法，只要任意一端没有明确提出断开连接，则保持TCP连接状态，在请求首部字段中的`Connection: keep-alive`即为表明使用了持久连接。

**HTTPS(Secure Hypertext Transfer Protocol)安全超文本传输协议**，是一个安全通信通道，它基于HTTP开发用于在客户计算机和服务器之间交换信息。它使用**安全套接字层**(SSL)进行信息交换，简单来说它是HTTP的安全版，是**使用TLS/SSL加密的HTTP协议**。    

HTTP协议采用明文传输信息，存在信息窃听、信息篡改和信息劫持的风险，而协议TLS/SSL具有身份验证、信息加密和完整性校验的功能，可以避免此类问题发生。

    
**TLS/SSL全称安全传输层协议Transport Layer Security**，是**介于TCP和HTTP之间的一层安全协议**，不影响原有的TCP协议和HTTP协议，所以使用HTTPS基本上不需要对HTTP页面进行太多的改造。


**HTTPS特点：**
基于HTTP协议，通过SSL或TLS提供**加密**处理数据（采用混合加密技术，中间者无法直接查看明文内容）、**验证对方身份**（通过证书认证客户端访问的是自己的服务器）以及**数据完整性保护**（防止传输的内容被中间人冒充或者篡改）。

<div align=center><img src=Pictures\HTTP与HTTPS的区别.webp></div>


### HTTPS如何加密？

#### 对称加密

对称加密(Symmetrical Encryption)顾名思义就是指**加密和解密时使用的密钥都是同样的密钥**。只要保证了密钥的安全性，那么整个通信过程也就是具有了机密性。

<div align=center><img src=Pictures\对称加密.jpg></div>

小灰和小红可以事先约定一种**对称加密方式**，并且**约定一个随机生成的密钥**。**后续的通信中**，信息发送方都使用密钥对信息加密，而信息接收方通过同样的密钥对信息解密。

虽然我们在后续的通信中对明文进行了加密，但是**第一次约定加密方式和密钥的通信仍然是明文**，如果第一次通信就已经被拦截了，那么密钥就会泄露给中间人，中间人仍然可以解密后续所有的通信内容。

比如我出于人道主义，想要帮助小明同学作弊，首先考试前我们会约定好一个暗号来传递选择题的答案，摸头发——A，摸耳朵——B，咳嗽——C，跺脚——D，于是一个加密方法就诞生了，这个加密方法只有我和小明知道，老师虽然看我抓耳挠腮但他顶多把我当成神经病，并没有直接证据说我作弊。

这种我和小明知道，别人不知道的加密方法就是一种对称加密算法,对称加密算法也是我们日常最常见的加密算法。这种算法🔑只有一把，**加密解密都用同一把钥匙**，一旦🔑泄露就全玩完了。

#### 非对称加密

非对称加密(Asymmetrical Encryption) 也被称为公钥加密，相对于对称加密来说，非对称加密是一种新的改良加密方式。密钥通过网络传输交换，它能够确保即使密钥被拦截，也不会暴露数据信息。非对称加密中有两个密钥，一个是公钥，一个是私钥，公钥进行加密，私钥进行解密。公开密钥可供任何人使用，私钥只有你自己能够知道。

<div align=center><img src=Pictures\非对称加密.jpg></div>

可以使用**非对称加密**，为密钥的传输做一层额外的保护。

**将a和b相乘得出乘积c很容易，但要是想要通过乘积c推导出a和b极难。即对一个大数进行因式分解极难。**

非对称加密算法就多了两个概念——**公钥c**和私钥b。

用法如下：**公钥加密的密文只能用私钥解密，私钥加密的密文只能用公钥解密**。

公钥我们可以随便公开，因为别人知道了公钥毫无用处，经过公钥加密后的密文只能通过私钥来解密。而**想要通过公钥推导出a和b极难**。但很明显的是，使用非对称加密效率不如对称加密，因为非对称加密需要有计算两个密钥的过程。

非对称加密的一组秘钥对中，包含一个**公钥**和一个**私钥**。**明文既可以用公钥加密，用私钥解密；也可以用私钥加密，用公钥解密**。

在小灰和小红建立通信的时候，小红首先把自己的**公钥**Key1发给小灰；收到小红的公钥以后，**小灰自己生成一个用于对称加密的密钥Key2**，并且**用刚才接收的公钥Key1对Key2进行加密**，发送给小红；**小红利用自己非对称加密的私钥**，解开了公钥Key1的加密（**公钥Key1的加密只能用小红自己的私钥解开**），获得了Key2的内容。**从此以后，两人就可以<font color=red>利用Key2进行对称加密的通信</font>了**。在通信过程中，**即使中间人在一开始就截获了公钥Key1，由于不知道私钥是什么，也无从解密**。

中间人虽然不知道小红的私钥是什么，但是在截获了小红的公钥Key1之后，却可以偷天换日，**自己另外生成一对公钥私钥，把自己的公钥Key3发送给小灰**。

小灰不知道公钥被偷偷换过，以为Key3就是小红的公钥。于是按照先前的流程，用Key3加密了自己生成的对称加密密钥Key2，发送给小红。这一次通信再次被中间人截获，中间人先用自己的私钥解开了Key3的加密，获得Key2，然后再用当初小红发来的Key1重新加密，再发给小红。这样一来，两个人后续的通信尽管用Key2做了对称加密，但是中间人已经掌握了Key2，所以可以轻松进行解密。

根本原因是小灰无法确认自己收到的公钥是不是小红自己的。

#### 数字证书

有必要引入第三方，一个权威的证书颁发机构（CA）来解决：

- 作为**服务端的小红**，首先把自己的**公钥Key1**发给证书颁发机构，向证书颁发机构申请证书。
- 证书颁发机构自己也有**一对公钥私钥**。**机构利用自己的私钥来加密Key1，并且通过服务端网址等信息生成一个证书签名，证书签名同样经过机构的私钥加密**。证书制作完成后，机构把证书发送给了**服务端小红**。
- 当小灰向小红请求通信的时候，小红不再直接返回自己的公钥，而是**把自己申请的证书返回给小灰**。
- 小灰收到证书以后，要做的第一件事情是**验证证书的真伪**。需要说明的是，**各大浏览器和操作系统已经维护了所有权威证书机构的名称和公钥**。所以小灰只需要知道是哪个机构颁布的证书，就可以**从本地找到对应的机构公钥，解密出证书签名**。
- 接下来，**小灰按照同样的签名规则，自己也生成一个证书签名，如果两个签名一致，说明证书是有效的**。验证成功后，小灰就可以放心地再次**利用机构公钥，解密出服务端小红的公钥Key1**。
- 像之前一样，小灰生成自己的对称加密密钥Key2，并且**用服务端公钥Key1加密Key2**，发送给小红。
- 最后，小红用自己的私钥解开加密，得到对称加密密钥Key2。于是**两人开始用Key2进行对称加密的通信**。

中间人是否可以自己也向权威机构申请一个证书，并且把小红发来的证书偷偷换成自己的证书呢？

没有用！因为**证书的签名是由服务端网址等信息生成的，并且经过机构私钥加密**，中间人也无法篡改！

网站在使用HTTPS前，需要向“CA机构”申请颁发一份数字证书，**数字证书里有证书持有者、证书持有者的公钥等信息**，服务器把证书传输给浏览器，浏览器从证书里取公钥就行了，证书就如身份证一样，可以**证明“该公钥对应该网站”**。

然而这里又有一个显而易见的问题了，证书本身的传输过程中，如何防止被篡改？即如何证明证书本身的真实性？数字证书怎么防伪呢？解决这个问题我们就基本接近胜利了！

**如何放防止数字证书被篡改？**

我们**把证书内容生成一份“签名”**，比对证书内容和签名是否一致就能察觉是否被篡改。这种技术就叫<font color=red>数字签名</font>。

<div align=center><img src=Pictures\数字签名生成与验证.jpg></div>

**数字签名的制作过程：**

- CA拥有非对称加密的私钥和公钥。
- CA对证书明文信息进行hash。
- 对hash后的值用私钥加密，得到数字签名。

**明文和数字签名共同组成了数字证书**，这样一份数字证书就可以颁发给网站了。

那浏览器拿到服务器传来的数字证书后，如何验证它是不是真的？（有没有被篡改、掉包）

**浏览器验证过程：**

- 拿到证书，得到明文T，数字签名S。
- 用CA机构的公钥对S解密（由于是浏览器信任的机构，所以浏览器保有它的公钥），得到S’。
- 用证书里说明的hash算法对明文T进行hash得到T’。
- 比较S’是否等于T’，等于则表明证书可信。

**数字证书的使用过程：**

- 第一步：首先，当爱丽丝开启一个新的浏览器第一次去访问鲍勃的时候，会**先让爱丽丝安装一个数字证书**，这个数字证书里包含的主要信息就是**CA机构的公钥**。
- 第二步：鲍勃发送来了CA机构颁发给自己的数字证书，**爱丽丝通过第一步中已经得到的公钥解密CA用私钥加密的Hash-a(这个过程就是非对称加密)，然后再用传递过来的HASH算法生成一个Hash-b，如果Hash-a === Hash-b就说明认证通过，确实是鲍勃发过来的**。

**SSL协议的握手过程：**

- 第一步：爱丽丝给出支持SSL协议版本号，一个客户端随机数(Client random，请注意这是第一个随机数)，客户端支持的加密方法等信息；
- 第二步：鲍勃收到信息后，确认双方使用的加密方法，并返回数字证书，一个服务器生成的随机数(Server random，注意这是第二个随机数)等信息；
- 第三步：爱丽丝确认数字证书的有效性，然后生成一个新的随机数(Premaster secret)，然后使用数字证书中的公钥，加密这个随机数，发给鲍勃。
- 第四步：鲍勃使用自己的私钥，获取爱丽丝发来的随机数(即Premaster secret)；(第三、四步就是非对称加密的过程了)
- 第五步：爱丽丝和鲍勃通过约定的加密方法(通常是AES算法)，使用前面三个随机数，生成对话密钥，用来加密接下来的通信内容。

<div align=center><img src=Pictures\数字证书.jpg></div>

**整个过程：**

- CA机构颁发数字证书给鲍勃；
- 爱丽丝和鲍勃进行SSL握手，爱丽丝通过数字证书确定鲍勃的身份；
- 爱丽丝和鲍勃传递三个随机数，第三个随机数通过非对称加密算法进行传递；
- 爱丽丝和鲍勃通过一个对称加密算法生成一个对话密钥，加密接下来的通信内容。

通信双方**通过对称加密来加密密文**，然后**使用非对称加密的方式来传递对称加密所使用的密钥**。这样**效率**和**安全**就都能保证了。

**中间人有可能篡改该证书吗？**

假设中间人篡改了证书的原文，由于他**没有CA机构的私钥**，所以无法得到此时加密后签名，无法相应地篡改签名。浏览器收到该证书后会发现原文和签名解密后的值不一致，则说明证书已被篡改，证书不可信，从而终止向服务器传输信息，防止信息泄露给中间人。

**既然不可能篡改，那整个证书有可能被掉包吗？**

假设有另一个网站B也拿到了CA机构认证的证书，它想搞垮网站A，想劫持网站A的信息。于是它成为中间人拦截到了A传给浏览器的证书，然后替换成自己的证书，传给浏览器，之后浏览器就会错误地拿到B的证书里的公钥了，会导致上文提到的漏洞。

其实这并不会发生，**因为证书里包含了网站A的信息，包括域名，浏览器把证书里的域名与自己请求的域名比对一下就知道有没有被掉包了**。

**为什么制作数字签名时需要hash一次？**

一方面是**性能问题**，**非对称加密效率较差**，证书信息一般较长，比较耗时。而**hash后得到的是固定长度的信息**（比如用md5算法hash后可以得到固定的128位的值），这样加密解密就会快很多。另一方面是**安全**上的原因。


### HTTPS的工作过程？

- 客户端发送自己支持的加密规则给服务器，代表告诉服务器要进行连接了；

- 服务器从中选出一套加密算法和hash算法以及自己的身份信息（地址等）以**证书**的形式发送给浏览器，证书中包含服务器信息，加密公钥，证书的办法机构；

- 客户端收到网站的证书之后要做下面的事情：
  - 验证证书的合法性；
  - 如果验证通过证书，浏览器会生成一串随机数，并用证书中的公钥进行加密；
  - 用约定好的hash算法计算握手消息，然后用生成的密钥进行加密，然后一起发送给服务器。

- 服务器接收到客户端传送来的信息，要做下面的事情：
  - 用私钥解析出密码，用密码解析握手消息，验证hash值是否和浏览器发来的一致；
  - 使用密钥加密消息；

- 如果计算法hash值一致，握手成功。


### HTTPS 的优缺点？

- 优点：
  - 使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户机和服务器；
  - HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比HTTP协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性；
  - HTTPS是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。

- 缺点：
  - HTTPS协议**握手阶段比较费时**，会使页面的加载时间延长近 50%，增加10%到20%的耗电；
  - HTTPS连接缓存不如HTTP高效，会增加数据开销和功耗，甚至已有的安全措施也会因此而受到影响；
  - SSL**证书需要钱**，功能越强大的证书费用越高，个人网站、小网站没有必要一般不会用；
  - SSL**证书通常需要绑定IP**，不能在同一IP上绑定多个域名，IPv4资源不可能支撑这个消耗；
  - HTTPS协议的**加密范围也比较有限**，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用。最关键的，SSL证书的信用链体系并不安全，特别是在某些国家可以控制CA根证书的情况下，中间人攻击一样可行。





# DNS：因特网的目录服务

识别主机有两种方式，通过**主机名**或者**IP地址**。人们喜欢便于记忆的主机名标识方式，而路由器则喜欢定长的、有着层次结构的IP地址。为了折衷这些不同的偏好，我们需要一种能进行**主机名到IP地址转换的目录服务**。这就是**域名系统**(Domain Name System, DNS)的主要任务。

一个域名往往对应多个DNS地址：
<div align=center><img src=Pictures\一个域名对应多个DNS.jpg width=80%></div>

[浏览器中输入网址到返回页面的全过程](#在浏览器输入网址后发生了什么)

## DNS解析

<div align=center><img src=Pictures\DNS解析.jpg></div>


浏览器输入地址，然后浏览器这个进程去调操作系统某个库里的`gethostbyname`函数(例如，Linux GNU glibc标准库的gethostbyname函数)，然后呢这个**函数通过网卡给DNS服务器发UDP请求**，接收结果，然后将结果给返回给浏览器。

我们在用chrome浏览器的时候，其实会先去**浏览器的DNS缓存**里头查询，DNS缓存中没有，再去调用gethostbyname函数；gethostbyname函数在试图进行DNS解析之前**首先检查域名是否在本地Hosts**里，如果没找到再去DNS服务器上查。


### DNS在域名解析上用UDP

UDP具有TCP所望尘莫及的**速度优势**。

虽然TCP协议中植入了各种安全保障功能，但是在实际执行的过程中会占用大量的系统开销，无疑使速度受到严重的影响。反观UDP由于排除了信息可靠传递机制，将安全和排序等功能移交给上层应用来完成，极大降低了执行时间，使速度得到了保证。

客户端向DNS服务器查询域名，一般返回的内容都不超过512字节，用UDP传输即可。不用经过TCP三次握手，这样DNS服务器负载更低，响应更快。

**DNS中也有一个地方用到了TCP协议。那就是区域传送**！

DNS的规范规定了2种类型的DNS服务器，一个叫**主DNS服务器**，一个叫**辅助DNS服务器**。在一个区中主DNS服务器从自己本机的数据文件中读取该区的DNS数据信息，而辅助DNS服务器则从区的主DNS服务器中读取该区的DNS数据信息。**当一个辅助DNS服务器启动时，它需要与主DNS服务器通信，并加载数据信息，这就叫做区传送(zone transfer)。这种情况下，使用TCP协议**。

这里之所以用TCP是因为**从主DNS上复制内容，需要保证可靠性**；并且**TCP协议传输的内容多**(UDP协议最大只能传512字节)！


### DNS如何做域名解析

<div align=center><img src=Pictures\DNS服务器的层次结构.jpg></div>

`www.tmall.com`对应的真正的域名为`www.tmall.com.`。末尾的`.`称为**根域名**，因为每个域名都有根域名，因此通常省略。

根域名的下一级，叫做**顶级域名**（top-level domain，缩写为TLD），比如`.com`、`.net`；

再下一级叫做**次级域名**（second-level domain，缩写为SLD），比如`www.tmall.com`里面的`.tmall`，这一级域名是用户可以注册的；

再下一级是**主机名**（host），比如`www.tmall.com`里面的`www`，又称为**三级域名**，这是用户在自己的域里面为服务器分配的名称，是用户可以任意分配的。

那么解析流程就是分级查询！

- 先在**本机的DNS**里头查，如果有就直接返回了；
- **本机DNS里头发现没有，就去根服务器里查**。根服务器发现这个域名是属于`com`域，因此根域DNS服务器会返回它所管理的`com`域中的DNS服务器的IP地址，意思是**虽然我不知道你要查的那个域名的地址，但你可以去`com`域问问看**；
- 本机的DNS接到又会向`com`域的DNS服务器发送查询消息。`com`域中也没有`www.tmall.com`这个域名的信息，和刚才一样，`com`域服务器会返回它下面的`tmall.com`域的DNS服务器的IP地址。

以此类推，只要重复前面的步骤，就可以顺藤摸瓜找到目标DNS服务器。



# TCP与UDP


## TCP/IP网络模型

TCP/IP模型是互联网的基础，它是一系列网络协议的总称。这些协议可以划分为四层，分别为链路层、网络层、传输层和应用层：

- 链路层：负责封装和解封装IP报文，发送和接受ARP/RARP报文等。
- 网络层：负责路由以及把**分组报文**(IP数据报)发送给目标网络或主机。
- 传输层：负责对报文进行分组和重组，并以**TCP或UDP协议**格式封装报文。
- 应用层：负责向用户提供应用程序，比如**HTTP**、FTP、Telnet、**DNS**、SMTP等。

<div align=center><img src=Pictures\TCPIP网络模型.png></div>

## UDP

UDP协议全称是**用户数据报协议(User Datagram Protocol)**，在网络中它与TCP协议一样用于处理数据包，是一种**无连接**的协议。UDP有**不提供数据包分组、组装**和不能对数据包进行排序的缺点，也就是说，当报文发送之后，是**无法得知其是否安全完整到达**的。

### UDP特点

无连接的、不可靠的、面向报文、无拥塞控制——速度快，消息易丢失：

<div align=center><img src=Pictures\UDP特点.png></div>

#### 面向无连接

首先UDP是不需要和TCP一样在发送数据前进行三次握手建立连接的，**想发数据就可以开始发送了**。并且也**只是数据报文的搬运工**，**不会对数据报文进行任何拆分和拼接操作**。

- 在发送端，应用层将数据传递给传输层的UDP协议，UDP只会给数据增加一个UDP头标识下是UDP协议，然后就传递给网络层了；
- 在接收端，网络层将数据传递给传输层，UDP只去除IP报文头就传递给应用层，不会任何拼接操作。
  
#### 有单播，多播，广播的功能

UDP不止支持一对一的传输方式，同样支持一对多，多对多，多对一的方式，也就是说UDP提供了单播，多播，广播的功能。

#### UDP是面向报文的

发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付IP层。UDP对应用层交下来的报文，**既不合并，也不拆分**，而是保留这些报文的边界。因此，应用程序必须**选择合适大小的报文**。

#### 不可靠性

首先不可靠性体现在**无连接上**，通信都不需要建立连接，想发就发，这样的情况肯定不可靠。

并且收到什么数据就传递什么数据，并且也不会备份数据，发送数据也**不会关心对方是否已经正确接收到数据了**。

再者网络环境时好时坏，但是UDP因为**没有拥塞控制**，一直会以恒定的速度发送数据。即使网络条件不好，也不会对发送速率进行调整。这样实现的弊端就是在**网络条件不好的情况下可能会导致丢包**，但是优点也很明显，在某些**实时性要求高的场景**（比如**电话会议**）就需要**使用UDP**而不是TCP。

<div align=center><img src=Pictures\UDP.gif></div>

UDP只会把想发的数据报文一股脑的丢给对方，并不在意数据有无安全完整到达。

#### 头部开销小，传输数据报文时高效

<div align=center><img src=Pictures\UDPHeader.png></div>

UDP头部包含了以下几个数据：

- 两个十六位的端口号，分别为**源端口**（可选字段）和**目标端口**
- 整个数据报文的长度
- 整个数据报文的检验和（IPv4可选字段），该字段用于发现头部信息和数据中的错误
  
因此UDP的头部开销小，只有八字节，相比TCP的至少二十字节要少得多，在传输数据报文时是很高效的。

### UDP应用场景

要求通信速度高的场景：
- 域名转换：DNS协议
- 文件传输：FTP协议
- 网络管理：SNMP协议
- 远程文件服务器：NFS协议


### 报文段格式

UDP的报文段共有2个字段：数据字段和首部字段(8字节、4个字段)：
<div align=center><img src=Pictures\UDP报文段.webp width=80%></div>

<div align=center><img src=Pictures\UDP报文段1.webp width=80%></div>



## TCP

TCP协议全称是**传输控制协议(Transmission Control Protocol)**，是一种**面向连接的、可靠的、基于字节流**的**传输层**通信协议，流就是指不间断的数据结构，你可以把它想象成排水管中的水流。基于TCP的**应用层**协议有**HTTP**、SMTP、FTP、TELNET和POP3。

### TCP特点

**数据传输可靠**，但因为需要建立连接、发送确认包等操作，导致**效率低**！

<div align=center><img src=Pictures\TCP特点.png></div>

**面向连接**

面向连接，是指发送数据之前必须在两端建立连接。建立连接的方法是**三次握手**，这样能建立可靠的连接。建立连接，是为数据的可靠传输打下了基础。

**仅支持单播传输**

每条TCP传输连接只能有两个端点，只能进行**点对点**的数据传输，不支持多播和广播传输方式。

**面向字节流**
TCP不像UDP一样那样一个个报文独立地传输，而是**在不保留报文边界的情况下以字节流方式进行传输**。

**可靠传输**

对于可靠传输，判断丢包，误码靠的是TCP的段编号以及确认号。TCP为了保证报文传输的可靠，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的字节发回一个相应的确认(ACK)；如果发送端实体在合理的往返时延(RTT)内未收到确认，那么对应的数据（假设丢失了）将会被重传。

**提供拥塞控制**

当网络出现拥塞的时候，TCP能够减小向网络注入数据的速率和数量，缓解拥塞。

**TCP提供全双工通信**

TCP允许通信双方的应用程序在任何时候都能发送数据，因为TCP连接的两端都设有缓存，用来临时存放双向通信的数据。当然，TCP可以立即发送一个数据段，也可以缓存一段时间以便一次发送更多的数据段（最大的数据段大小取决于MSS）。



### TCP应用场景

要求**通信数据可靠**时，即数据要准确无误地传递给对方：

- 传输文件：HTTP、HTTPS、FTP等协议；
- 传输邮件：POP、SMTP等协议；
- 远程终端接入：TELNET协议。
  

### 报文段格式

- TCP虽面向字节流，但传送的**数据单元**为**报文段**；
- 报文段 = **首部 + 数据** 2部分
  
TCP的全部功能体现在它首部中各字段的作用，首部前20个字符固定、后面有4n个字节是根据需而增加的选项，故**TCP首部最小长度为20字节**。

<div align=center><img src=Pictures\TCP报文.webp></div>

**ACK：确认标记位；ack：确认号！**

<div align=center><img src=Pictures\TCP报文1.png></div>



### TCP连接过程

建立一个TCP连接的过程为（三次握手的过程）：

<div align=center><img src=Pictures\TCP连接过程.png></div>

<div align=center><img src=Pictures\TCP.gif></div>

**第一次握手**

客户端向服务端发送**连接请求报文段**。该报文段中包含自身的数据通讯**初始序号**。请求发送后，客户端便进入`SYN-SENT`状态。

**第二次握手**

服务端收到连接请求报文段后，如果同意连接，则会发送一个**应答**，该应答中也会包含自身的数据通讯**初始序号**，发送完成后便进入`SYN-RECEIVED`状态。

**第三次握手**

当客户端收到连接同意的应答后，还要向服务端发送一个**确认报文**。客户端发完这个报文段后便进入`ESTABLISHED`状态，服务端收到这个应答后也进入`ESTABLISHED`状态，此时连接建立成功。

<div align=center><img src=Pictures\TCP报文1.png></div>
<div align=center><img src=Pictures\TCP三次握手.webp width=80%></div>
<div align=center><img src=Pictures\TCP三次握手1.png></div>

成功进行TCP的三次握手后，就建立起一条TCP连接，即可传送应用层数据。因为TCP提供的是全双工通信，故通信双方的应用进程在任何时候都能发送数据；**三次握手期间，任何1次未收到对面的回复，则都会重发**。




**为什么TCP建立连接需要三次握手，而不是两次？**

这是因为这是为了防止出现**失效的连接请求报文段被服务端接收**的情况，从而产生错误。

防止服务器端**因接收了早已失效的连接请求报文，从而一直等待客户端请求，最终导致形成死锁、浪费资源**。

<div align=center><img src=Pictures\三次握手2.jpg></div>


#### SYN洪泛攻击

从上可看出：**服务端的TCP资源分配时刻 = 完成第二次握手时；而客户端的TCP资源分配时刻 = 完成第三次握手时**。这就使得服务器易于受到SYN洪泛攻击，即**同时多个客户端发起连接请求，从而需进行多个请求的TCP连接资源分配**。





### TCP断开链接



<div align=center><img src=Pictures\TCP报文1.png></div>

<div align=center><img src=Pictures\TCP断开连接.webp></div>

<div align=center><img src=Pictures\TCP断开连接1.png></div>

TCP是全双工的，**在断开连接时两端都需要发送FIN和ACK**。

**第一次挥手**

若客户端A认为数据发送完成，则它需要向服务端B发送**连接释放请求**。

**第二次挥手**

B收到连接释放请求后，会告诉应用层要释放TCP链接。然后会发送`ACK`包，并进入`CLOSE_WAIT`状态，此时表明A到B的连接已经释放，不再接收A发的数据了。但是因为TCP连接是双向的，所以**B仍旧可以发送数据给A**。

**第三次挥手**

B如果此时还有没发完的数据会继续发送，完毕后会向A发送连接释放请求，然后B便进入`LAST-ACK`状态。

**第四次挥手**

A收到释放请求后，向B发送**确认应答**，此时A进入`TIME-WAIT`状态。该状态会持续**2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃）时间**，若该时间段内没有B的重发请求的话，就进入CLOSED状态。当B收到确认应答后，也便进入CLOSED状态。


**为什么TCP释放连接需四次挥手？**

<div align=center><img src=Pictures\四次挥手1.jpg></div>

当主机向服务器发送“断开连接请求”，服务器返回“确认释放连接”时，只是完成了**单向断开**，即服务器还是可以向主机发送数据，主机还是可以接收数据的。

当服务器也发送“释放连接请求”，主机返回“连接释放确认”报文后，表示此时服务器已经没有数据要发送给主机，双方都无法通信了。

**为什么客户端关闭连接前要等待2MSL时间？**

- 即`TIME - WAIT`状态的作用是什么？
- `MSL` = 最长报文段寿命(`Maximum Segment Lifetime`)

原因1：为了**保证客户端发送的最后1个连接释放确认报文能到达服务器**，从而**使得服务器能正常释放连接**。否则，服务器将无法进入关闭状态。

<div align=center><img src=Pictures\四次挥手2.jpg></div>

原因2：**防止早已失效的连接请求报文出现在本连接中**。

客户端发送了最后1个连接释放请求确认报文后，再经过2MSL时间，则**可使本连接持续时间内所产生的所有报文段都从网络中消失**。即，**<font color=red>在下1个新的连接中就不会出现早已失效的连接请求报文</font>**。


### 无差错传输

对比于UDP，TCP的传输是可靠的、无差错的。那么，为什么TCP的传输为什么是可靠的、无差错的呢？

**无差错**：即传输信道不出差错。
**发送和接收效率匹配**：即无论发送方以多快的速度发送数据，接收方总来得及处理收到的数据。

#### 滑动窗口协议

<div align=center><img src=Pictures/滑动窗口协议.png></div>

- 对于发送端：
  - **每收到一个确认帧，发送窗口就向前滑动一个帧的距离(未收到确认帧，则窗口不移动)**
  - 当发送窗口内无可发送的帧时（即窗口内的帧全部是已发送但未收到确认的帧），发送方就会停止发送，直到收到接收方发送的确认帧使窗口移动，窗口内有可以发送的帧，之后才开始继续发送

<div align=center><img src=Pictures/滑动窗口协议1.webp></div>

- 对于接收端：**当收到数据帧后，将窗口向前移动一个位置，并发回确认帧**，若收到的数据帧落在接收窗口之外，则一律丢弃。

<div align=center><img src=Pictures/滑动窗口协议2.webp></div>


**滑动窗口协议的重要特性：**

- **只有接收窗口向前滑动、接收方发送了确认帧时，发送窗口才有可能（只有发送方收到确认帧才是一定）向前滑动**
- 停止-等待协议、后退N帧协议和选择重传协议只是在**发送窗口大小和接收窗口大小**上有所差别：
  - 停止等待协议：发送窗口大小=1，接收窗口大小=1；即**单帧滑动窗口**等于停止-等待协议
  - 后退N帧协议：发送窗口大小>1，接收窗口大小=1。
  - 选择重传协议：发送窗口大小>1，接收窗口大小>1。

- 当接收窗口的大小为1时，可保证帧有序接收。
- 数据链路层的滑动窗口协议中，窗口的大小在传输过程中是固定的（注意要与TCP的滑动窗口协议区别）



#### 无差错传输的解决方案

核心思想：采用一些可靠传输协议，使得

- 出现差错时，让发送方重传差错数据：即<font color=red>出错重传</font>；
- 当接收方来不及接收收到的数据时，可通知发送方降低发送数据的效率：即<font color=red>速度匹配</font>

针对上述2个问题，分别采用的解决方案是：**自动重传协议**以及**流量控制和拥塞控制协议**。

##### 自动重传请求协议ARQ

即`Auto Repeat reQuest`，具体介绍如下：

<div align=center><img src=Pictures/自动重传协议.jpg></div>

<div align=center><img src=Pictures/ARQ类型.webp></div>


**类型1：停等式ARQ(Stop-and-Wait)**

原理：(单帧滑动窗口)停止-等待协议 + 超时重传。即，发送窗口大小=1、接收窗口大小=1。

停止-等待协议的协议原理如下：

- 发送方每发送一帧，要等到接收方的应答信号后才能发送下一帧
- 接收方每接收一帧，都要反馈一个应答信号，表示可接下一帧
- 若接收方不反馈应答信号，则发送方必须一直等待


**类型2：后退N帧协议**

也称：连续ARQ协议

原理：多帧滑动窗口 + 累计确认 + 后退N帧 + 超时重传。即，发送窗口大小>1、接收窗口大小=1

具体描述
- 发送方：采用多帧滑动窗口的原理，可连续发送多个数据帧，而不需等待对方确认
- 接收方：采用**累计确认**和**后退N帧**的原理，只允许按顺序接收帧。具体原理如下：

<div align=center><img src=Pictures/自动重传协议1.jpg></div>

源站向目的站发送数据帧：

<div align=center><img src=Pictures/自动重传协议2.jpg></div>


**类型3：选择重传ARQ(Selective Repeat)**

原理：多帧滑动窗口 + 累计确认 + 后退N帧 + 超时重传。即，发送窗口大小>1、接收窗口大小>1

类似于类型2(后退N帧协议)，此处仅仅是**接收窗口大小的区别**，故此处不作过多描述。

特点：
- 优：因连续发送数据帧而提高了信道的利用率
- 缺：重传时又必须把原来已经传送正确的数据帧进行重传（仅因为这些数据帧前面有一个数据帧出了错），将导致传送效率降低

由此可见，若信道传输质量很差，导致误码率较大时，后退N帧协议不一定优于停止-等待协议。


##### 流量控制和拥塞控制

**措施1：流量控制**

<div align=center><img src=Pictures/流量控制.jpg width=80%></div>

<div align=center><img src=Pictures/流量控制2.webp></div>

**死锁问题：**

<div align=center><img src=Pictures/流量控制2.jpg></div>


**措施2：拥塞控制**

**防止过多的数据注入到网络中**，使得网络中的路由器和链路不致于过载。

拥塞：对网络中的资源需求 > 该资源所能提供的部分。网络中的链路容量和交换结点中的缓存和处理机都有着工作的极限，**当网络的需求超过它们的工作极限时，就出现了拥塞**。

与 “流量控制”的区别：

<div align=center><img src=Pictures/拥塞控制.webp></div>

具体解决方案，共分为2个解决方案：**慢开始与拥塞避免**、**快重传与快恢复**。

**解决方案1：慢开始与拥塞避免**

- 拥塞窗口

发送方维持一个状态变量：拥塞窗口(cwnd, congestion window)

<div align=center><img src=Pictures/拥塞控制2.jpg width=80%></div>

- **慢开始**算法

  - 原理：当主机开始发送数据时，由小到大逐渐增大拥塞窗口数值（即发送窗口数值），从而由小到大逐渐增大发送报文段。

  - 目的：**开始传输时，试探网络的拥塞情况**

  - 具体措施

<div align=center><img src=Pictures/拥塞控制3.webp></div>

<div align=center><img src=Pictures/拥塞控制4.webp></div>

慢开始的“慢”指：**一开始发送报文段时拥塞窗口(cwnd)设置得较小(为1)**，使得发送方在开始时只发送一个报文段（目的是试探一下网络的拥塞情况）。并不是指拥塞窗口(cwnd)的增长速率慢。


- 拥塞避免算法

  - 原理：**使得拥塞窗口(cwnd)按线性规律缓慢增长**：每经过一个往返时间RTT，发送方的拥塞窗口(cwnd)加1。

  - 拥塞避免并不可避免拥塞，只是将拥塞窗口按现行规律缓慢增长，使得网络比较不容易出现拥塞

  - 相比慢开始算法的加倍，拥塞窗口增长速率缓慢得多


<div align=center><img src=Pictures/拥塞避免.webp></div>

- 方案描述

**为了防止拥塞窗口(cwnd)增长过大而引起网络拥塞，采用慢开始与拥塞避免**，具体规则如下：

<div align=center><img src=Pictures/拥塞控制5.jpg></div>

- 示例

<div align=center><img src=Pictures/拥塞控制6.webp></div>


**解决方案2：快重传与快恢复**

快重传与快恢复的解决方案是对慢开始与拥塞避免算法的改进。

- 快重传算法

  - 原理

    - **接收方每收到一个失序的报文段后就立即发出重复确认**（为的是使发送方及早知道有报文段没有到达对方），而不要等到自己发送数据时才进行捎带确认
    - 发送方只要一连收到3个重复确认就立即重传对方尚未收到的报文段，而不必 继续等待设置的重传计时器到期
  
  - 作用：由于**发送方尽早重传未被确认的报文段**，因此采用快重传后可以使整个网络吞吐量提高约20%

<div align=center><img src=Pictures/快重传.webp></div>

- 快恢复

  当发送方连续收到3个重复确认后，就：

    - 执行乘法减小算法：把慢开始门限(ssthresh)设置为出现拥塞时发送方窗口值的一半 = 拥塞窗口的1半
    - 将拥塞窗口(cwnd)值设置为慢开始门限ssthresh减半后的数值 = 拥塞窗口的1半
    - 执行加法增大算法：执行拥塞避免算法，使拥塞窗口缓慢地线性增大。

- 方案描述

  为了优化慢开始与拥塞避免的解决方案，在上述方案中加入快重传与快恢复算法，具体规则如下：


<div align=center><img src=Pictures/快重传快恢复.jpg></div>

<div align=center><img src=Pictures/拥塞控制7.webp></div>

## TCP和UDP的比较

|              |                     UDP                    |                   TCP                  |
|:------------:|:------------------------------------------:|:--------------------------------------:|
|   是否连接   |                   无连接                   |                面向连接                |
|   是否可靠   |    不可靠传输，不使用流量控制和拥塞控制    |    可靠传输，使用流量控制和拥塞控制    |
| 连接对象个数 | 支持一对一，一对多，多对一和多对多交互通信 |            只能是一对一通信            |
|   传输方式   |                  面向报文                  |               面向字节流               |
|   首部开销   |             首部开销小，仅8字节            |       首部最小20字节，最大60字节       |
|   适用场景   | 适用于**实时应用**（IP电话、视频会议、直播等） | 适用于要求**可靠传输**的应用，例如文件传输 |

<div align=center><img src=Pictures/TCPvsUDP.webp></div>


# TCP三次握手与四次挥手

## TCP连接的建立（三次握手）

<div align=center><img src=Pictures/三次握手.gif></div>

三次握手建立连接的首要目的是**同步序列号**。只有**同步了序列号**才有可靠传输，TCP许多特性都依赖于序列号实现，比如流量控制、丢包重传等，这也是三次握手中的报文称为SYN的原因，SYN的全称就叫**Synchronize Sequence Numbers**（同步序列号）。


<div align=center><img src=Pictures/TCP头部格式.webp></div>


最开始的时候客户端和服务器都是处于CLOSED状态。主动打开连接的为客户端，被动打开连接的是服务器。

在三次握手建立连接的阶段，是不会传输TCP报文段的，传输的是`传输控制块（TCB）`，**传输控制块TCB(`Transmission Control Block`)**<font color=red>存储了每一个连接中的一些重要信息</font>，如：TCP连接表，指向发送和接收缓存的指针，指向重传队列的指针，当前的发送和接收序号等等。

- TCP`服务器进程`先创建`传输控制块TCB`，时刻准备接受客户进程的连接请求，此时服务器就进入了`LISTEN`（监听）状态；

- TCP`客户进程`也是先创建**传输控制块TCB[SYN=1, seq=x]**，然后向服务器发出`连接请求报文`，这时报文首部中的**同步位**`SYN=1`，同时选择一个**初始序列号**`seq=x`，此时，TCP客户端进程进入了`SYN-SENT（同步已发送状态）`状态。TCP规定，<font color=red>SYN报文段（SYN=1的报文段）不能携带数据，但需要消耗掉一个序号</font>。

- TCP`服务器`收到请求报文后，如果同意连接，则构建好`TCB[SYN=1, seq=y, ACK=1, ack=x+1]`发出`确认报文`。确认报文中应该**ACK=1，SYN=1**，**确认号是ack=x+1**，同时也要为自己初始化一个**序列号seq=y**，此时，TCP服务器进程进入了`SYN-RCVD（同步收到）`状态。<font color=red>这个报文也不能携带数据，但是同样要消耗一个序号</font>。

- TCP`客户进程`收到确认后，还要**向服务器给出确认**。确认报文的**ACK=1，ack=y+1**，自己的**序列号seq=x+1**，此时，TCP连接建立，客户端进入`ESTABLISHED（已建立连接）`状态。TCP规定，<font color=red>ACK报文段可以携带数据，但是如果不携带数据则不消耗序号</font>。

- 当`服务器`收到客户端的确认后也进入`ESTABLISHED`状态，此后双方就可以开始通信了。

<div align=center><img src=Pictures/三次握手.jpg></div>


### 《自顶向下》解释三次握手

<div align=center><img src=Pictures/三次握手1.jpg></div>

<div align=center><img src=Pictures/TCP三次握手的状态变迁.webp width=80%></div>

- 第一步：客户端向服务器端发送包含了一个随机初始序号(`client_isn`)的**SYN报文段**。
  客户端的TCP首先向服务器端的TCP发送一个特殊的TCP报文段，该报文段中不包含应用层数据，但在报文段的首部中的一个标志位(`SYN比特`)被置为1。因此这个特殊报文段被称为**SYN报文段**。
  客户会随机地选择一个**初始序号**(`client_isn`)，并将此编号放置于该起始的TCP`SYN报文段`的序号字段中。
  该报文段会被封装在一个IP数据报中，并发送给服务器。

- 第二步：服务器端接受到数据报后，向客户端发送**SYNACK报文段**(SYNACK segment)
  服务器从接收到的数据报中提取出TCP`SYN报文段`，为该TCP连接分配TCP缓存和变量，并向该客户TCP发送允许连接的报文段。
  在报文段的首部包含3个重要信息：**SYN**比特被置为1；**确认号字段ack**被置为`client_isn + 1`；服务器选择自己的**初始序号**(`server_isn`)。
  我收到了你发起建立连接的SYN分组，该分组带有初始序号`client_isn`。我同意建立该连接，我自己的初始序号为`server_isn`。

- 第三步：收到SYNACK报文段后，客户端向服务器端发送报文段，**对服务器的允许连接的报文段进行确认**。
  **确认号**字段`ack`被置为`server_isn + 1`，初始序号被置为`client_isn + 1`。**因为连接已经建立了，所以SYN比特被置为0**。

一旦完成这3个步骤，客户和服务器主机就可以相互发送包括数据的报文段了。在以后每一个报文段中，SYN比特都将被置为0。 



### 问题

- **为何不直接在第一次握手就带上报文段消息，非要第三次才可以带？**

    因为<font color=red>TCP是要保证数据的不丢失且可靠</font>，如果在第一次就带上报文段消息，此次建立连接很有可能就会失败，那么就**不能保证数据的不丢失**了，在不可靠的机制上进行这种操作，换来的代价太大，每次发送报文段的资源也会增大，得不偿失；

    而**第三次握手的时候，客户端已经知道服务器端准备好了**，所以只要告诉服务器端自己准备好了就okay了，所以此时带上报文段信息没有任何问题。

- **可不可以只握手两次？**

    不可以，主要<font color=red>防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误</font>。
    
    三次握手主要是解决这样一个常见的问题，客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了，由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时**重新向服务器发送这条报文**，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。此时<font color=red>此前滞留的那一次请求连接，网络通畅了到达了服务器，**这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接**，这将导致不必要的错误和资源的浪费</font>。

    如果采用的是三次握手，就算是那一次失效的报文传送过来了，**服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认**。<font color=red>由于**服务器收不到确认**，就知道客户端并没有请求连接</font>。


## TCP连接的释放（四次挥手）

<div align=center><img src=Pictures/四次挥手.gif></div>

数据传输完毕后，双方都可释放连接。最开始的时候，客户端和服务器都是处于`ESTABLISHED`状态，然后客户端主动关闭，服务器被动关闭。

1.  `客户端进程`发出**连接释放报文**，<font color=red>告诉服务器端，客户端需要关闭了</font>，并且停止发送数据。释放数据报文首部，**FIN=1**，其**序列号**为`seq=u`（<font color=red>等于前面已经传送过来的数据的最后一个字节的序号加1</font>），此时，客户端进入`FIN-WAIT-1`（**终止等待1**）状态。 TCP规定，<font color=red>`FIN报文段`即使不携带数据，也要消耗一个序号</font>。

2. `服务器`收到连接释放报文，发出**确认报文**，<font color=red>告诉客户端收到了客户端要关闭的消息了</font>，**ACK=1，ack=u+1**，并且带上自己的**序列号seq=v**，此时，服务端就进入了`CLOSE-WAIT`（关闭等待）状态。<font color=red>TCP服务器通知高层的应用进程，进程需要关闭连接了</font>，这时候处于**半关闭状态**，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个`CLOSE-WAIT`状态持续的时间。

3. `客户端`收到服务器的确认请求后，此时，客户端就进入`FIN-WAIT-2`（**终止等待2**）状态，等待服务器发送`连接释放报文`（在这之前还需要接受<font color=red>服务器发送的最后的数据</font>）。

4. `服务器`将<font color=red>最后的数据</font>发送完毕后，就向客户端发送**连接释放报文**，<font color=red>告知客户端，服务器端现在要关闭了</font>，`FIN=1`，`ack=u+1`，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为`seq=w`，此时，服务器就进入了`LAST-ACK`（最后确认）状态，等待客户端的确认。

5. `客户端`收到服务器的连接释放报文后，必须**发出确认**，<font color=red>告知服务器端，客户端已经知道了你准备好关闭了</font>，`ACK=1`，`ack=w+1`，而自己的序列号是`seq=u+1`，此时，客户端就进入了`TIME-WAIT`（**时间等待**）状态。注意**此时TCP连接还没有释放，必须经过`2*MSL`（最长报文段寿命——最长报文段传输时间）的时间后**，当客户端`撤销相应的TCB`后，才进入`CLOSED`状态。
  
6. `服务器`只要收到了客户端发出的确认，立即进入`CLOSED`状态。同样，`撤销TCB`后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。


<div align=center><img src=Pictures/四次挥手.jpg></div>

<div align=center><img src=Pictures/四次挥手.webp width=70%></div>

四次挥手过程只涉及了两种报文，分别是FIN和ACK：

- FIN就是结束连接的意思，谁发出FIN报文，就表示它将不会再发送任何数据，关闭这一方向上的传输通道；

- ACK就是确认的意思，用来通知对方：你方的发送通道已经关闭。

每个方向都需要一个FIN和一个ACK，因此通常被称为四次挥手。这里一点需要注意是：**主动关闭连接的，才有TIME_WAIT状态**。


### TIME_WAIT

当收到被动方发来的FIN报文后，主动方会立刻回复ACK，表示确认对方的发送通道已经关闭，接着就处于TIME_WAIT状态。

TIME_WAIT状态的连接，在主动方看来确实快已经关闭了。然后，被动方没有收到ACK报文前，还是处于LAST_ACK状态。

TIME-WAIT的状态尤其重要，主要是两个原因：

- 防止具有相同「四元组」的**旧数据包被收到**；

- 保证「被动关闭连接」的一方能被正确的关闭，即**保证最后的ACK能让被动关闭方接收，从而帮助其正常关闭**。

**原因一：防止旧连接的数据包**

TIME-WAIT的一个作用是**防止收到历史数据，从而导致数据错乱**的问题。

假设TIME-WAIT没有等待时间或时间过短，被延迟的数据包抵达后会发生什么呢？

<div align=center><img src=Pictures\接收到历史数据的异常.webp></div>

上图黄色框框，服务端在关闭连接之前发送的SEQ = 301报文，被网络延迟了。这时有相同端口的TCP连接被复用后，被延迟的SEQ = 301抵达了客户端，那么客户端是有可能正常接收这个过期的报文，这就会产生数据错乱等严重的问题。

所以，TCP就设计出了这么一个机制，**经过2MSL这个时间，足以让两个方向上的数据包都被丢弃，使得原来连接的数据包在网络中都自然消失，再出现的数据包一定都是新建立连接所产生的**。


**原因二：保证连接正确关闭**

TIME-WAIT的另外一个作用是**等待足够的时间以确保最后的ACK能让被动关闭方接收，从而帮助其正常关闭**。

假设TIME-WAIT没有等待时间或时间过短，断开连接会造成什么问题呢？

<div align=center><img src=Pictures\没有确保正常断开的异常.webp></div>


上图红色框框客户端四次挥手的最后一个ACK报文如果在网络中被丢失了，此时如果客户端TIME-WAIT过短或没有，则就直接进入了CLOSE状态了，那么服务端则会一直处在LASE-ACK状态。

当客户端发起建立连接的SYN请求报文后，服务端会发送RST报文给客户端，连接建立的过程就会被终止。

MSL全称是`Maximum Segment Lifetime`，它定义了**一个报文在网络中的最长生存时间**（**报文每经过一次路由器的转发，IP头部的TTL字段就会减1，减到0时报文就被丢弃，这就限制了报文的最长存活时间**）。

**为什么是2MSL的时长呢？**

这其实是相当于**至少允许报文丢失一次**。比如，若ACK在一个MSL内丢失，这样被动方重发的FIN会在第2个MSL内到达，TIME_WAIT状态的连接可以应对。

**为什么不是4或者8MSL的时长呢？**

你可以想象一个丢包率达到百分之一的糟糕网络，**连续两次丢包的概率只有万分之一，这个概率实在是太小了，忽略它比解决它更具性价比**。

因此，TIME_WAIT和FIN_WAIT2状态的最大时长都是2MSL，由于在Linux系统中，MSL的值固定为30秒，所以它们都是60秒。


### 问题

1. 为何不能三次挥手呢？
    首先如果去掉最后一次挥手，那么服务器端就不知道自己要关闭的报文有没有传输成功，可能半路上就失败了，但是此时客户端不知道，导致客户端一直在等待服务器关闭，但是此时服务器端直接就关闭了；
    
    如果中间的两次挥手合并，那是肯定不行的，因为此时服务器端可能还有很多报文未处理完，此时直接关闭肯定会对传输有很大影响。

2. 为什么客户端在收到服务器端发来的FIN包后要等2个最长报文段传输时间？
   防止最后自己发去的`ack`没传送到服务器，如果服务器没收到客户端的`ack`，肯定会选择重发一次`FIN`包，那么此时如果客户端已经关闭了，客户端就不能再发`ack`确认收到了。至于为何是2个报文段传输时间，因为刚好一去一回嘛… 2个最长报文传输时间没有FIN包发来，就说明服务器已经关闭了，客户端也就可以安心关闭了。

3. 为什么建立连接是三次握手，关闭连接确是四次挥手呢？
    建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。

    而关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送，从而导致多了一次。

4. 如果已经建立了连接，但是客户端突然出现故障了怎么办？
    TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。


## TCP状态

客户端TCP状态：
<div align=center><img src=Pictures/客户端TCP状态.jpg></div>

客户中的TCP向服务器中的TCP发送一个**SYN报文段**。在发送过SYN报文段后，客户TCP进入了**SYN_SENT状态**。 当客户TCP处在SYN_SENf状态时，它**等待来自服务器TCP的对客户所发报文段进行确认且SYN比特被置为1的一个报文段**。收到这样一个报文段之后，客户TCP进入**ESTABIJSHED**(已建立)状态。当处在ESTABIJSHED状态时，TCP客户就能发送和接收包含有效载荷数据(即应用层产生的数据)的TCP报文段了。

客户应用程序决定要关闭该连接，客户TCP发送一个带有FIN比特被置为1的TCP报文段，并进入**FIN_WAIT_1**状态。当处在FIN_WAIT_l状态时，客户TCP等待一个来自服务器的带有确认的TCP报文段。当它收到该报文段时，客户TCP进入**FIN_WAIT_2**状态。 当处在FIN_WAIT_2状态时，客户等待 来自服务器的FIN比特被置为1的另一个报文段；当收到该报文段后，客户TCP对服务器的报文段进行确认，并进入**TIME_WAIT**状态。假定ACK丢失，TIME_WAIT状态使TCP客户重传最后的确认报文。在TIME_WAIT状态中所消耗的时间是与具体实现有关的，而典型的值是30秒、1分钟或2分钟。经过等待后，连接就正式关闭，客户端所有资源（包括端口号）将被释放。

服务器端TCP状态：
<div align=center><img src=Pictures/服务器端TCP状态.jpg></div>







