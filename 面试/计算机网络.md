# 计算机网络体系结构

计算机网络体系结构分为3种：OSI体系结构、TCP / IP体系结构、五层体系结构

- OSI体系结构：概念清楚且理念完整，但复杂且不实用
- TCP/IP体系结构：含了一系列构成互联网基础的网络协议，是Internet的核心协议，被广泛应用于局域网和广域网
- 五层体系结构：融合了OSI与TCP/IP的体系结构，目的是为了学习与讲解计算机原理

<div align=center><img src=Pictures/计算机网络体系结构.webp></div>

其中TCP/IP体系结构较为广泛：

<div align=center><img src=Pictures/TCP_IP体系结构.webp></div>

OSI的体系结构详细介绍：

<div align=center><img src=Pictures\OSI的体系结构.png></div>


# HTTP与HTTPS

HTTP协议全称`Hyper Text Transfer Protocol`超文本传输协议，位于TCP/IP四层模型当中的应用层。

应用层(HTTP/FTP)；传输层(TCP/UDP)；网络层(IP/ARP)。



## 什么是HTTP

<div align=center><img src=Pictures/HTTP.jpg></div>

**超文本传输协议**(HyperText Transfer Protocol)，是一个基于**请求与响应**，**无状态**的**应用层**协议，**常基于TCP/IP协议传输数据**，互联网上应用最为广泛的一种网络协议。设计HTTP的初衷是为了**提供一种发布和接收HTML页面的方法**。

### 常用的HTTP方法

- GET：用于**请求访问**已经被URI（Uniform Resource Identifier——统一资源标识符——表示的是web上每一种**可用的资源**，如 HTML文档、图像、视频片段、程序等）识别的资源，可以通过URL（Uniform Resource Locator——统一资源定位符）传参给服务器；
- POST：用于**传输信息给服务器**，主要功能与GET方法类似，但一般推荐使用POST方式。
- PUT：传输文件，报文主体中包含文件内容，保存到对应URI位置。
- HEAD：获得报文首部，与GET方法类似，只是不返回报文主体，一般用于验证URI是否有效。
- DELETE：删除文件，与PUT方法相反，删除对应URI位置的文件。
- OPTIONS：查询相应URI支持的HTTP方法。

**GET方法与POST方法的区别：**

- GET重点在从服务器上获取资源，POST重点在向服务器发送数据；
- GET传输数据是**通过URL（Uniform Resource Locator，统一资源定位符）请求**，以`field（字段）= value`的形式，置于URL后，并用"?"连接，多个请求数据间用"&"连接，如`http://127.0.0.1/Test/login.action?name=admin&password=admin`，这个过程**用户是可见**的；
    POST传输数据通过HTTP的POST机制，**将字段与对应值封存在请求实体中**发送给服务器，这个过程**对用户是不可见的**；
- GET方式只能支持ASCII字符，向服务器传的中文字符可能会乱码。
POST支持标准字符集，可以正确传递中文字符。

<div align=center><img src=Pictures\GET_POST区别.webp></div>

**常见的HTTP相应状态码：**

200：请求被正常处理
404：服务器无法找到对应资源
500：服务器内部错误

HTTP协议采用**请求/响应**的工作方式：

<div align=center><img src=Pictures\HTTP工作方式.webp></div>

### HTTP请求报文

HTTP的请求报文由`请求行、请求头和请求体`组成：

<div align=center><img src=Pictures\HTTP请求报文.webp></div>

**请求行：**

- 作用
  声明`请求方法、主机域名、资源路径和协议版本`
- 结构
  请求行的组成：`请求方法 + 请求路径 + 协议版本`

注：空格不能省

<div align=center><img src=Pictures\HTTP请求行组成.webp></div>

假设：请求报文采用GET方法，URL地址为`http://www.tsinghua.edu.cn/chn/yxsz/index.htm`且使用HTTP1.1版本，则请求行是：`GET /chn/yxsz/index.htm HTTP/1.1`。

**请求头：**

- 作用：声明客户端、服务器/报文的部分信息
- 使用方式：采用`header(字段名)：value(值)`的方式

<div align=center><img src=Pictures\常见请求Header.webp width=80%></div>

举例：(URL地址：`http://www.tsinghua.edu.cn/chn/yxsz/index.htm`）
Host：www.tsinghua.edu.cn (表示主机域名）
User - Agent：Mozilla/5.0 (表示用户代理是使用Netscape浏览器）


**请求体：**

作用：存放**需发送给服务器的数据信息**。它是可选部分，如**GET请求就无请求数据**。

<div align=center><img src=Pictures\HTTP请求体.webp></div>


**关于请求报文的总结如下：**

<div align=center><img src=Pictures\HTTP请求报文1.webp></div>

**HTTP请求报文示例：**

<div align=center><img src=Pictures\HTTP请求报文示例.webp></div>


### HTTP响应报文

HTTP的响应报文包括：**状态行、响应头和响应体**

<div align=center><img src=Pictures\HTTP响应报文.png></div>

**状态行：**

- 作用
  声明 协议版本，状态码，状态码描述
- 组成
  状态行有协议版本、状态码和状态信息组成
  
其中，空格不能省

<div align=center><img src=Pictures\HTTP响应报文状态行.webp></div>

**响应头：**

- 作用：声明客户端、服务器 / 报文的部分信息
- 使用方式：采用`header(字段名):value(值)`的方式

<div align=center><img src=Pictures\HTTP响应报文响应头.webp width=70%></div>

**响应体：**

- 作用：存放需返回给客户端的数据信息
- 使用方式：和请求体是一致的，同样分为：任意类型的数据交换格式、键值对形式和分部分形式

<div align=center><img src=Pictures\HTTP响应报文响应体.webp></div>

**总结：**

<div align=center><img src=Pictures\HTTP响应报文总结.webp></div>


### 在浏览器输入网址后发生了什么

<div align=center><img src=Pictures\打开一个网页的过程.webp></div>

“天龙八部”：

客户端输入URL回车，**DNS(Domain Name System)解析域名**得到服务器的IP地址，服务器在80**端口**监听客户端请求，端口通过**TCP/IP协议**建立连接。

**第一步：浏览器查找该域名的IP地址——DNS域名解析**

浏览器把域名发送给系统默认DNS服务器。如果该服务器本地有缓存，且缓存未过期，则直接返回结果否则向上一级DNS服务器查询，直到DNS根服务器。

**第二步：通过三次握手，建立了客户端和服务器之间的TCP连接：**

**第三步：浏览器根据解析得到的IP地址向web服务器发送一个HTTP请求**

浏览器知道了网址的对应服务器IP地址和端口，然后就通过TCP协议发起网络请求。

**第四步：服务器收到请求并进行处理**

**第五步：服务器返回一个响应**

**第六步：浏览器对该响应进行解码，渲染显示**

**第七步：页面显示完成后，浏览器发送异步请求。**

页面显示完成后客户端仍与服务器端保持着联系。它会持续与服务器保持联系来及时更新一些页面信息。

**第八步：关闭TCP连接**


### HTTP1.1 与 HTTP1.0的区别

| 版本  | 产生时间  |  内容 | 发展现状  |
|---|---|---|---|
| HTTP/0.9	 | 1991年  | 不涉及数据包传输，规定客户端和服务器之间通信格式，只能GET请求  |  没有作为正式的标准 |
| HTTP/1.0  | 1996年  | 传输内容格式不限制，增加PUT、PATCH、HEAD、 OPTIONS、DELETE命令  | 正式作为标准  |
| HTTP/1.1  | 1997年  | **持久连接(长连接)**、节约带宽、HOST域、管道机制、分块传输编码  |2015年前使用最广泛   |
| HTTP/2  | 2015年  | **多路复用**、服务器推送、头信息压缩、二进制协议等  | 逐渐覆盖市场  |

Http1.1 比 Http1.0 多了以下优点：

- 引入**持久连接**，即**在同一个TCP的连接中可传送多个HTTP请求与响应**
- 多个请求与响应可同时进行、可重叠
- 引入更加多的请求头与响应头
  如与身份认证、状态管理和Cache缓存等机制相关的、HTTP1.0无host字段



下图是Akamai公司建立的一个官方的演示，使用`HTTP/1.1`(1997年)和`HTTP/2`(2015年)同时请求379张图片，观察请求的时间，明显看出`HTTP/2`性能占优势：

<div align=center><img src=Pictures\Http1.1VS2.jpg></div>

`HTTP/2`采用**多路复用**技术：通过**单一的`HTTP/2`连接请求**发起**多重的请求-响应消息**，**多个请求stream共享一个TCP连接**，实现**多流并行**而**不是依赖建立多个TCP连接**。


### HTTP处理长连接的方式

<div align=center><img src=Pictures\HTTP处理长连接.jpg></div>

## 什么是HTTPS

HTTPS是**身披SSL外壳的HTTP**。HTTPS是一种通过计算机网络进行**安全通信**的传输协议，**经由HTTP进行通信，利用SSL/TLS(TLS是传输层加密协议，前身是SSL协议)建立全信道，加密数据包**。HTTPS使用的主要目的是**提供对网站服务器的身份认证**，同时**保护交换数据的隐私与完整性**。


## HTTP与HTTPS比较

HTTP特点：
- 无状态：HTTP服务器不保存关于客户的任何信息。
    比如**访问一个网站需要反复进行登录操作**。
- 无连接：HTTP/1.1之前，由于无状态特点，每次请求需要通过TCP三次握手四次挥手，和服务器重新建立连接。
    比如某个客户机在短时间多次请求同一个资源，服务器并不能区别是否已经响应过用户的请求，所以每次需要重新响应请求，需要耗费不必要的时间和流量。
- 基于请求和响应：由客户端发起请求，服务端响应
- **不安全**：通信使用**明文**、请求和响应不会对通信方进行确认、无法保护数据的完整性。

针对无状态的解决策略：
- 通过Cookie/Session技术
- HTTP/1.1**持久连接**（HTTP **keep-alive**）方法，只要任意一端没有明确提出断开连接，则保持TCP连接状态，在请求首部字段中的`Connection: keep-alive`即为表明使用了持久连接。

**HTTPS(Secure Hypertext Transfer Protocol)安全超文本传输协议**，是一个安全通信通道，它基于HTTP开发用于在客户计算机和服务器之间交换信息。它使用**安全套接字层**(SSL)进行信息交换，简单来说它是HTTP的安全版，是**使用TLS/SSL加密的HTTP协议**。    

HTTP协议采用明文传输信息，存在信息窃听、信息篡改和信息劫持的风险，而协议TLS/SSL具有身份验证、信息加密和完整性校验的功能，可以避免此类问题发生。

    
**TLS/SSL全称安全传输层协议Transport Layer Security**，是介于TCP和HTTP之间的一层安全协议，不影响原有的TCP协议和HTTP协议，所以使用HTTPS基本上不需要对HTTP页面进行太多的改造。


HTTPS特点：
基于HTTP协议，通过SSL或TLS提供**加密**处理数据（采用混合加密技术，中间者无法直接查看明文内容）、**验证对方身份**（通过证书认证客户端访问的是自己的服务器）以及**数据完整性保护**（防止传输的内容被中间人冒充或者篡改）。

<div align=center><img src=Pictures\HTTP与HTTPS的区别.webp></div>


### HTTPS如何加密？

小灰和小红可以事先约定一种**对称加密方式**，并且**约定一个随机生成的密钥**。**后续的通信中**，信息发送方都使用密钥对信息加密，而信息接收方通过同样的密钥对信息解密。

虽然我们在后续的通信中对明文进行了加密，但是**第一次约定加密方式和密钥的通信仍然是明文**，如果第一次通信就已经被拦截了，那么密钥就会泄露给中间人，中间人仍然可以解密后续所有的通信内容。

可以使用**非对称加密**，为密钥的传输做一层额外的保护。

非对称加密的一组秘钥对中，包含一个**公钥**和一个**私钥**。**明文既可以用公钥加密，用私钥解密；也可以用私钥加密，用公钥解密**。

在小灰和小红建立通信的时候，小红首先把自己的**公钥**Key1发给小灰；收到小红的公钥以后，**小灰自己生成一个用于对称加密的密钥Key2**，并且用刚才接收的公钥Key1对Key2进行加密，发送给小红；**小红利用自己非对称加密的私钥**，解开了公钥Key1的加密，获得了Key2的内容。**从此以后，两人就可以利用Key2进行对称加密的通信了**。在通信过程中，即使中间人在一开始就截获了公钥Key1，由于不知道私钥是什么，也无从解密。

中间人虽然不知道小红的私钥是什么，但是在截获了小红的公钥Key1之后，却可以偷天换日，**自己另外生成一对公钥私钥，把自己的公钥Key3发送给小灰**。

小灰不知道公钥被偷偷换过，以为Key3就是小红的公钥。于是按照先前的流程，用Key3加密了自己生成的对称加密密钥Key2，发送给小红。这一次通信再次被中间人截获，中间人先用自己的私钥解开了Key3的加密，获得Key2，然后再用当初小红发来的Key1重新加密，再发给小红。这样一来，两个人后续的通信尽管用Key2做了对称加密，但是中间人已经掌握了Key2，所以可以轻松进行解密。


有必要引入第三方，一个权威的证书颁发机构（CA）来解决：

- 作为**服务端的小红**，首先把自己的公钥Key1发给证书颁发机构，向证书颁发机构申请证书。
- 证书颁发机构自己也有**一对公钥私钥**。**机构利用自己的私钥来加密Key1，并且通过服务端网址等信息生成一个证书签名，证书签名同样经过机构的私钥加密**。证书制作完成后，机构把证书发送给了**服务端小红**。
- 当小灰向小红请求通信的时候，小红不再直接返回自己的公钥，而是**把自己申请的证书返回给小灰**。
- 小灰收到证书以后，要做的第一件事情是**验证证书的真伪**。需要说明的是，**各大浏览器和操作系统已经维护了所有权威证书机构的名称和公钥**。所以小灰只需要知道是哪个机构颁布的证书，就可以**从本地找到对应的机构公钥，解密出证书签名**。
- 接下来，**小灰按照同样的签名规则，自己也生成一个证书签名，如果两个签名一致，说明证书是有效的**。验证成功后，小灰就可以放心地再次**利用机构公钥，解密出服务端小红的公钥Key1**。
- 像之前一样，小灰生成自己的对称加密密钥Key2，并且**用服务端公钥Key1加密Key2**，发送给小红。
- 最后，小红用自己的私钥解开加密，得到对称加密密钥Key2。于是**两人开始用Key2进行对称加密的通信**。

中间人是否可以自己也向权威机构申请一个证书，并且把小红发来的证书偷偷换成自己的证书呢？

没有用！因为**证书的签名是由服务端网址等信息生成的，并且经过机构私钥加密**，中间人也无法篡改！





# DNS：因特网的目录服务

识别主机有两种方式，通过**主机名**或者**IP地址**。人们喜欢便于记忆的主机名标识方式，而路由器则喜欢定长的、有着层次结构的IP地址。为了折衷这些不同的偏好，我们需要一种能进行**主机名到IP地址转换的目录服务**。这就是**域名系统**(Domain Name System, DNS)的主要任务。

一个域名往往对应多个DNS地址：
<div align=center><img src=Pictures\一个域名对应多个DNS.jpg width=80%></div>

[浏览器中输入网址到返回页面的全过程](#在浏览器输入网址后发生了什么)

## DNS解析

<div align=center><img src=Pictures\DNS解析.jpg></div>


浏览器输入地址，然后浏览器这个进程去调操作系统某个库里的`gethostbyname`函数(例如，Linux GNU glibc标准库的gethostbyname函数)，然后呢这个**函数通过网卡给DNS服务器发UDP请求**，接收结果，然后将结果给返回给浏览器。

我们在用chrome浏览器的时候，其实会先去**浏览器的DNS缓存**里头查询，DNS缓存中没有，再去调用gethostbyname函数；gethostbyname函数在试图进行DNS解析之前**首先检查域名是否在本地Hosts**里，如果没找到再去DNS服务器上查。


### DNS在域名解析上用UDP

DNS中也有一个地方用到了TCP协议。那就是区域传送！

DNS的规范规定了2种类型的DNS服务器，一个叫**主DNS服务器**，一个叫**辅助DNS服务器**。在一个区中主DNS服务器从自己本机的数据文件中读取该区的DNS数据信息，而辅助DNS服务器则从区的主DNS服务器中读取该区的DNS数据信息。当一个辅助DNS服务器启动时，它需要与主DNS服务器通信，并加载数据信息，这就叫做区传送(zone transfer)。这种情况下，使用TCP协议。

这里之所以用TCP是因为从主DNS上复制内容，需要保证**可靠性**；并且TCP协议传输的**内容大**(UDP协议最大只能传512字节)！


### DNS如何做域名解析

<div align=center><img src=Pictures\DNS服务器的层次结构.jpg></div>

`www.tmall.com`对应的真正的域名为`www.tmall.com.`。末尾的`.`称为**根域名**，因为每个域名都有根域名，因此通常省略。

根域名的下一级，叫做**顶级域名**（top-level domain，缩写为TLD），比如`.com`、`.net`；

再下一级叫做**次级域名**（second-level domain，缩写为SLD），比如`www.tmall.com`里面的`.tmall`，这一级域名是用户可以注册的；

再下一级是**主机名**（host），比如`www.tmall.com`里面的`www`，又称为**三级域名**，这是用户在自己的域里面为服务器分配的名称，是用户可以任意分配的。

那么解析流程就是分级查询！

- 先在本机的DNS里头查，如果有就直接返回了；
- 本机DNS里头发现没有，就去根服务器里查。根服务器发现这个域名是属于`com`域，因此根域DNS服务器会返回它所管理的`com`域中的DNS服务器的IP地址，意思是**虽然我不知道你要查的那个域名的地址，但你可以去`com`域问问看**；
- 本机的DNS接到又会向`com`域的DNS服务器发送查询消息。`com`域中也没有`www.tmall.com`这个域名的信息，和刚才一样，`com`域服务器会返回它下面的`tmall.com`域的DNS服务器的IP地址。

以此类推，只要重复前面的步骤，就可以顺藤摸瓜找到目标DNS服务器。



# TCP与UDP


## TCP/IP网络模型

TCP/IP模型是互联网的基础，它是一系列网络协议的总称。这些协议可以划分为四层，分别为链路层、网络层、传输层和应用层：

- 链路层：负责封装和解封装IP报文，发送和接受ARP/RARP报文等。
- 网络层：负责路由以及把**分组报文**(IP数据报)发送给目标网络或主机。
- 传输层：负责对报文进行分组和重组，并以**TCP或UDP协议**格式封装报文。
- 应用层：负责向用户提供应用程序，比如**HTTP**、FTP、Telnet、**DNS**、SMTP等。

<div align=center><img src=Pictures\TCPIP网络模型.png></div>

## UDP

UDP协议全称是**用户数据报协议(User Datagram Protocol)**，在网络中它与TCP协议一样用于处理数据包，是一种**无连接**的协议。UDP有**不提供数据包分组、组装**和不能对数据包进行排序的缺点，也就是说，当报文发送之后，是**无法得知其是否安全完整到达**的。

### UDP特点

无连接的、不可靠的、面向报文、无拥塞控制——速度快，消息易丢失：

<div align=center><img src=Pictures\UDP特点.png></div>

#### 面向无连接

首先UDP是不需要和TCP一样在发送数据前进行三次握手建立连接的，**想发数据就可以开始发送了**。并且也只是数据报文的搬运工，**不会对数据报文进行任何拆分和拼接操作**。

- 在发送端，应用层将数据传递给传输层的UDP协议，UDP只会给数据增加一个UDP头标识下是UDP协议，然后就传递给网络层了；
- 在接收端，网络层将数据传递给传输层，UDP只去除IP报文头就传递给应用层，不会任何拼接操作。
  
#### 有单播，多播，广播的功能

UDP不止支持一对一的传输方式，同样支持一对多，多对多，多对一的方式，也就是说UDP提供了单播，多播，广播的功能。

#### UDP是面向报文的

发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付IP层。UDP对应用层交下来的报文，**既不合并，也不拆分**，而是保留这些报文的边界。因此，应用程序必须**选择合适大小的报文**。

#### 不可靠性

首先不可靠性体现在**无连接上**，通信都不需要建立连接，想发就发，这样的情况肯定不可靠。

并且收到什么数据就传递什么数据，并且也不会备份数据，发送数据也**不会关心对方是否已经正确接收到数据了**。

再者网络环境时好时坏，但是UDP因为**没有拥塞控制**，一直会以恒定的速度发送数据。即使网络条件不好，也不会对发送速率进行调整。这样实现的弊端就是在**网络条件不好的情况下可能会导致丢包**，但是优点也很明显，在某些**实时性要求高的场景**（比如**电话会议**）就需要**使用UDP**而不是TCP。

<div align=center><img src=Pictures\UDP.gif></div>

UDP只会把想发的数据报文一股脑的丢给对方，并不在意数据有无安全完整到达。

#### 头部开销小，传输数据报文时高效

<div align=center><img src=Pictures\UDPHeader.png></div>

UDP头部包含了以下几个数据：

- 两个十六位的端口号，分别为**源端口**（可选字段）和**目标端口**
- 整个数据报文的长度
- 整个数据报文的检验和（IPv4可选字段），该字段用于发现头部信息和数据中的错误
  
因此UDP的头部开销小，只有八字节，相比TCP的至少二十字节要少得多，在传输数据报文时是很高效的。

### UDP应用场景

要求通信速度高的场景：
- 域名转换：DNS协议
- 文件传输：FTP协议
- 网络管理：SNMP协议
- 远程文件服务器：NFS协议


### 报文段格式

UDP的报文段共有2个字段：数据字段和首部字段(8字节、4个字段)：
<div align=center><img src=Pictures\UDP报文段.webp width=80%></div>

<div align=center><img src=Pictures\UDP报文段1.webp width=80%></div>



## TCP

TCP协议全称是**传输控制协议(Transmission Control Protocol)**，是一种**面向连接的、可靠的、基于字节流**的**传输层**通信协议，流就是指不间断的数据结构，你可以把它想象成排水管中的水流。基于TCP的**应用层**协议有**HTTP**、SMTP、FTP、TELNET和POP3。

### TCP特点

**数据传输可靠**，但因为需要建立连接、发送确认包等操作，导致**效率低**！

<div align=center><img src=Pictures\TCP特点.png></div>

**面向连接**

面向连接，是指发送数据之前必须在两端建立连接。建立连接的方法是**三次握手**，这样能建立可靠的连接。建立连接，是为数据的可靠传输打下了基础。

**仅支持单播传输**

每条TCP传输连接只能有两个端点，只能进行**点对点**的数据传输，不支持多播和广播传输方式。

**面向字节流**
TCP不像UDP一样那样一个个报文独立地传输，而是**在不保留报文边界的情况下以字节流方式进行传输**。

**可靠传输**

对于可靠传输，判断丢包，误码靠的是TCP的段编号以及确认号。TCP为了保证报文传输的可靠，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的字节发回一个相应的确认(ACK)；如果发送端实体在合理的往返时延(RTT)内未收到确认，那么对应的数据（假设丢失了）将会被重传。

**提供拥塞控制**

当网络出现拥塞的时候，TCP能够减小向网络注入数据的速率和数量，缓解拥塞。

**TCP提供全双工通信**

TCP允许通信双方的应用程序在任何时候都能发送数据，因为TCP连接的两端都设有缓存，用来临时存放双向通信的数据。当然，TCP可以立即发送一个数据段，也可以缓存一段时间以便一次发送更多的数据段（最大的数据段大小取决于MSS）。



### TCP应用场景

要求**通信数据可靠**时，即数据要准确无误地传递给对方：

- 传输文件：HTTP、HTTPS、FTP等协议；
- 传输邮件：POP、SMTP等协议；
- 远程终端接入：TELNET协议。
  

### 报文段格式

- TCP虽面向字节流，但传送的**数据单元**为**报文段**；
- 报文段 = **首部 + 数据** 2部分
  
TCP的全部功能体现在它首部中各字段的作用，首部前20个字符固定、后面有4n个字节是根据需而增加的选项，故**TCP首部最小长度为20字节**。

<div align=center><img src=Pictures\TCP报文.webp></div>

<div align=center><img src=Pictures\TCP报文1.png></div>



### TCP连接过程

建立一个TCP连接的过程为（三次握手的过程）：

<div align=center><img src=Pictures\TCP连接过程.png></div>

<div align=center><img src=Pictures\TCP.gif></div>

**第一次握手**

客户端向服务端发送连接请求报文段。该报文段中包含自身的数据通讯**初始序号**。请求发送后，客户端便进入`SYN-SENT`状态。

**第二次握手**

服务端收到连接请求报文段后，如果同意连接，则会发送一个**应答**，该应答中也会包含自身的数据通讯**初始序号**，发送完成后便进入`SYN-RECEIVED`状态。

**第三次握手**

当客户端收到连接同意的应答后，还要向服务端发送一个**确认报文**。客户端发完这个报文段后便进入`ESTABLISHED`状态，服务端收到这个应答后也进入`ESTABLISHED`状态，此时连接建立成功。

<div align=center><img src=Pictures\TCP报文1.png></div>
<div align=center><img src=Pictures\TCP三次握手.webp width=80%></div>
<div align=center><img src=Pictures\TCP三次握手1.png></div>

成功进行TCP的三次握手后，就建立起一条TCP连接，即可传送应用层数据。因为TCP提供的是全双工通信，故通信双方的应用进程在任何时候都能发送数据；**三次握手期间，任何1次未收到对面的回复，则都会重发**。




**为什么TCP建立连接需要三次握手，而不是两次？**

这是因为这是为了防止出现**失效的连接请求报文段被服务端接收**的情况，从而产生错误。

防止服务器端**因接收了早已失效的连接请求报文，从而一直等待客户端请求，最终导致形成死锁、浪费资源**。

<div align=center><img src=Pictures\三次握手2.jpg></div>


#### SYN洪泛攻击

从上可看出：**服务端的TCP资源分配时刻 = 完成第二次握手时；而客户端的TCP资源分配时刻 = 完成第三次握手时**。这就使得服务器易于受到SYN洪泛攻击，即**同时多个客户端发起连接请求，从而需进行多个请求的TCP连接资源分配**。





### TCP断开链接



<div align=center><img src=Pictures\TCP报文1.png></div>

<div align=center><img src=Pictures\TCP断开连接.webp></div>

<div align=center><img src=Pictures\TCP断开连接1.png></div>

TCP是全双工的，**在断开连接时两端都需要发送FIN和ACK**。

**第一次挥手**

若客户端A认为数据发送完成，则它需要向服务端B发送**连接释放请求**。

**第二次挥手**

B收到连接释放请求后，会告诉应用层要释放TCP链接。然后会发送`ACK`包，并进入`CLOSE_WAIT`状态，此时表明A到B的连接已经释放，不再接收A发的数据了。但是因为TCP连接是双向的，所以**B仍旧可以发送数据给A**。

**第三次挥手**

B如果此时还有没发完的数据会继续发送，完毕后会向A发送连接释放请求，然后B便进入`LAST-ACK`状态。

**第四次挥手**

A收到释放请求后，向B发送**确认应答**，此时A进入`TIME-WAIT`状态。该状态会持续**2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃）时间**，若该时间段内没有B的重发请求的话，就进入CLOSED状态。当B收到确认应答后，也便进入CLOSED状态。


**为什么TCP释放连接需四次挥手？**

<div align=center><img src=Pictures\四次挥手1.jpg></div>

**为什么客户端关闭连接前要等待2MSL时间？**

- 即`TIME - WAIT`状态的作用是什么？
- `MSL` = 最长报文段寿命(`Maximum Segment Lifetime`)

原因1：为了**保证客户端发送的最后1个连接释放确认报文能到达服务器**，从而**使得服务器能正常释放连接**。

<div align=center><img src=Pictures\四次挥手2.jpg></div>

原因2：**防止早已失效的连接请求报文出现在本连接中**。

客户端发送了最后1个连接释放请求确认报文后，再经过2MSL时间，则**可使本连接持续时间内所产生的所有报文段都从网络中消失**。即，**在下1个新的连接中就不会出现早已失效的连接请求报文**。


### 无差错传输

对比于UDP，TCP的传输是可靠的、无差错的。那么，为什么TCP的传输为什么是可靠的、无差错的呢？

无差错：即传输信道不出差错。
发送和接收效率匹配：即无论发送方以多快的速度发送数据，接收方总来得及处理收到的数据。

#### 滑动窗口协议

<div align=center><img src=Pictures/滑动窗口协议.webp></div>

- 对于发送端：
  - **每收到一个确认帧，发送窗口就向前滑动一个帧的距离**
  - 当发送窗口内无可发送的帧时（即窗口内的帧全部是已发送但未收到确认的帧），发送方就会停止发送，直到收到接收方发送的确认帧使窗口移动，窗口内有可以发送的帧，之后才开始继续发送

<div align=center><img src=Pictures/滑动窗口协议1.webp></div>

- 对于接收端：**当收到数据帧后，将窗口向前移动一个位置，并发回确认帧**，若收到的数据帧落在接收窗口之外，则一律丢弃。

<div align=center><img src=Pictures/滑动窗口协议2.webp></div>


**滑动窗口协议的重要特性：**

- 只有接收窗口向前滑动、接收方发送了确认帧时，发送窗口才有可能（只有发送方收到确认帧才是一定）向前滑动
- 停止-等待协议、后退N帧协议和选择重传协议只是在**发送窗口大小和接收窗口大小**上有所差别：
  - 停止等待协议：发送窗口大小=1，接收窗口大小=1；即 单帧滑动窗口 等于 停止-等待协议
  - 后退N帧协议：发送窗口大小>1，接收窗口大小=1。
  - 选择重传协议：发送窗口大小>1，接收窗口大小>1。

- 当接收窗口的大小为1时，可保证帧有序接收。
- 数据链路层的滑动窗口协议中，窗口的大小在传输过程中是固定的（注意要与TCP的滑动窗口协议区别）



### 无差错传输的解决方案

核心思想：采用一些可靠传输协议，使得

- 出现差错时，让发送方重传差错数据：即**出错重传**；
- 当接收方来不及接收收到的数据时，可通知发送方降低发送数据的效率：即**速度匹配**

针对上述2个问题，分别采用的解决方案是：**自动重传协议**以及**流量控制和拥塞控制协议**。

#### 自动重传请求协议ARQ

即`Auto Repeat reQuest`，具体介绍如下：

<div align=center><img src=Pictures/自动重传协议.jpg></div>

<div align=center><img src=Pictures/ARQ类型.webp></div>


**类型1：停等式ARQ(Stop-and-Wait)**

原理：(单帧滑动窗口)停止-等待协议 + 超时重传。即，发送窗口大小=1、接收窗口大小=1。

停止-等待协议的协议原理如下：

- 发送方每发送一帧，要等到接收方的应答信号后才能发送下一帧
- 接收方每接收一帧，都要反馈一个应答信号，表示可接下一帧
- 若接收方不反馈应答信号，则发送方必须一直等待


**类型2：后退N帧协议**

也称：连续ARQ协议

原理：多帧滑动窗口 + 累计确认 + 后退N帧 + 超时重传。即，发送窗口大小>1、接收窗口大小=1

具体描述
- 发送方：采用多帧滑动窗口的原理，可连续发送多个数据帧，而不需等待对方确认
- 接收方：采用**累计确认**和**后退N帧**的原理，只允许按顺序接收帧。具体原理如下：

<div align=center><img src=Pictures/自动重传协议1.jpg></div>

源站向目的站发送数据帧：

<div align=center><img src=Pictures/自动重传协议2.jpg></div>


**类型3：选择重传ARQ(Selective Repeat)**

原理：多帧滑动窗口 + 累计确认 + 后退N帧 + 超时重传。即，发送窗口大小>1、接收窗口大小>1

类似于类型2(后退N帧协议)，此处仅仅是**接收窗口大小的区别**，故此处不作过多描述。

特点：
- 优：因连续发送数据帧而提高了信道的利用率
- 缺：重传时又必须把原来已经传送正确的数据帧进行重传（仅因为这些数据帧前面有一个数据帧出了错），将导致传送效率降低

由此可见，若信道传输质量很差，导致误码率较大时，后退N帧协议不一定优于停止-等待协议。


#### 流量控制和拥塞控制

**措施1：流量控制**

<div align=center><img src=Pictures/流量控制.jpg width=80%></div>

<div align=center><img src=Pictures/流量控制2.webp></div>

**死锁问题：**

<div align=center><img src=Pictures/流量控制2.jpg></div>


**措施2：拥塞控制**

**防止过多的数据注入到网络中**，使得网络中的路由器和链路不致于过载。

拥塞：对网络中的资源需求 > 该资源所能提供的部分。网络中的链路容量和交换结点中的缓存和处理机都有着工作的极限，**当网络的需求超过它们的工作极限时，就出现了拥塞**。

与 “流量控制”的区别：

<div align=center><img src=Pictures/拥塞控制.webp></div>

具体解决方案，共分为2个解决方案：**慢开始与拥塞避免**、**快重传与快恢复**。

**解决方案1：慢开始与拥塞避免**

- 拥塞窗口

发送方维持一个状态变量：拥塞窗口(cwnd, congestion window)

<div align=center><img src=Pictures/拥塞控制2.jpg width=80%></div>

- 慢开始算法

  - 原理：当主机开始发送数据时，由小到大逐渐增大拥塞窗口数值（即发送窗口数值），从而由小到大逐渐增大发送报文段。

  - 目的：开始传输时，试探网络的拥塞情况

  - 具体措施

<div align=center><img src=Pictures/拥塞控制3.webp></div>

<div align=center><img src=Pictures/拥塞控制4.webp></div>

慢开始的“慢”指：一开始发送报文段时拥塞窗口(cwnd)设置得较小(为1)，使得发送方在开始时只发送一个报文段（目的是试探一下网络的拥塞情况）。并不是指拥塞窗口(cwnd)的增长速率慢。


- 拥塞避免算法

  - 原理：使得拥塞窗口(cwnd)按线性规律缓慢增长：每经过一个往返时间RTT，发送方的拥塞窗口(cwnd)加1。

  - 拥塞避免并不可避免拥塞，只是将拥塞窗口按现行规律缓慢增长，使得网络比较不容易出现拥塞

  - 相比慢开始算法的加倍，拥塞窗口增长速率缓慢得多


<div align=center><img src=Pictures/拥塞避免.webp></div>

- 方案描述

为了防止拥塞窗口(cwnd)增长过大而引起网络拥塞，采用慢开始与拥塞避免，具体规则如下：

<div align=center><img src=Pictures/拥塞控制5.jpg></div>

- 示例

<div align=center><img src=Pictures/拥塞控制6.webp></div>


**解决方案2：快重传与快恢复**

快重传与快恢复的解决方案是对慢开始与拥塞避免算法的改进。

- 快重传算法

  - 原理

    - 接收方每收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方），而不要等到自己发送数据时才进行捎带确认
    - 发送方只要一连收到3个重复确认就立即重传对方尚未收到的报文段，而不必 继续等待设置的重传计时器到期
  
  - 作用：由于发送方尽早重传未被确认的报文段，因此采用快重传后可以使整个网络吞吐量提高约20%

<div align=center><img src=Pictures/快重传.webp></div>

- 快恢复

  当发送方连续收到3个重复确认后，就：

    - 执行乘法减小算法：把慢开始门限(ssthresh)设置为出现拥塞时发送方窗口值的一半 = 拥塞窗口的1半
    - 将拥塞窗口(cwnd)值设置为慢开始门限ssthresh减半后的数值 = 拥塞窗口的1半
    - 执行加法增大算法：执行拥塞避免算法，使拥塞窗口缓慢地线性增大。

- 方案描述

  为了优化慢开始与拥塞避免的解决方案，在上述方案中加入快重传与快恢复算法，具体规则如下：


<div align=center><img src=Pictures/快重传快恢复.jpg></div>

<div align=center><img src=Pictures/拥塞控制7.webp></div>

## TCP和UDP的比较

|              |                     UDP                    |                   TCP                  |
|:------------:|:------------------------------------------:|:--------------------------------------:|
|   是否连接   |                   无连接                   |                面向连接                |
|   是否可靠   |    不可靠传输，不使用流量控制和拥塞控制    |    可靠传输，使用流量控制和拥塞控制    |
| 连接对象个数 | 支持一对一，一对多，多对一和多对多交互通信 |            只能是一对一通信            |
|   传输方式   |                  面向报文                  |               面向字节流               |
|   首部开销   |             首部开销小，仅8字节            |       首部最小20字节，最大60字节       |
|   适用场景   | 适用于实时应用（IP电话、视频会议、直播等） | 适用于要求可靠传输的应用，例如文件传输 |

<div align=center><img src=Pictures/TCPvsUDP.webp></div>


# TCP三次握手与四次挥手

## TCP连接的建立（三次握手）

<div align=center><img src=Pictures/三次握手.gif></div>

三次握手建立连接的首要目的是**同步序列号**。只有**同步了序列号**才有可靠传输，TCP许多特性都依赖于序列号实现，比如流量控制、丢包重传等，这也是三次握手中的报文称为SYN的原因，SYN的全称就叫**Synchronize Sequence Numbers**（同步序列号）。


<div align=center><img src=Pictures/TCP头部格式.webp></div>


最开始的时候客户端和服务器都是处于CLOSED状态。主动打开连接的为客户端，被动打开连接的是服务器。

在三次握手建立连接的阶段，是不会传输TCP报文段的，传输的是`传输控制块（TCB）`，**传输控制块TCB(`Transmission Control Block`)**<font color=red>存储了每一个连接中的一些重要信息</font>，如：TCP连接表，指向发送和接收缓存的指针，指向重传队列的指针，当前的发送和接收序号等等。

- TCP`服务器进程`先创建`传输控制块TCB`，时刻准备接受客户进程的连接请求，此时服务器就进入了`LISTEN`（监听）状态；

- TCP`客户进程`也是先创建**传输控制块TCB[SYN=1, seq=x]**，然后向服务器发出`连接请求报文`，这时报文首部中的**同步位**`SYN=1`，同时选择一个**初始序列号**`seq=x`，此时，TCP客户端进程进入了`SYN-SENT（同步已发送状态）`状态。TCP规定，<font color=red>SYN报文段（SYN=1的报文段）不能携带数据，但需要消耗掉一个序号</font>。

- TCP`服务器`收到请求报文后，如果同意连接，则构建好`TCB[SYN=1, seq=y, ACK=1, ack=x+1]`发出`确认报文`。确认报文中应该**ACK=1，SYN=1**，**确认号是ack=x+1**，同时也要为自己初始化一个**序列号seq=y**，此时，TCP服务器进程进入了`SYN-RCVD（同步收到）`状态。<font color=red>这个报文也不能携带数据，但是同样要消耗一个序号</font>。

- TCP`客户进程`收到确认后，还要**向服务器给出确认**。确认报文的**ACK=1，ack=y+1**，自己的**序列号seq=x+1**，此时，TCP连接建立，客户端进入`ESTABLISHED（已建立连接）`状态。TCP规定，<font color=red>ACK报文段可以携带数据，但是如果不携带数据则不消耗序号</font>。

- 当`服务器`收到客户端的确认后也进入`ESTABLISHED`状态，此后双方就可以开始通信了。

<div align=center><img src=Pictures/三次握手.jpg></div>


### 《自顶向下》解释三次握手

<div align=center><img src=Pictures/三次握手1.jpg></div>

<div align=center><img src=Pictures/TCP三次握手的状态变迁.webp width=80%></div>

- 第一步：客户端向服务器端发送包含了一个随机初始序号(`client_isn`)的**SYN报文段**。
  客户端的TCP首先向服务器端的TCP发送一个特殊的TCP报文段，该报文段中不包含应用层数据，但在报文段的首部中的一个标志位(`SYN比特`)被置为1。因此这个特殊报文段被称为**SYN报文段**。
  客户会随机地选择一个**初始序号**(`client_isn`)，并将此编号放置于该起始的TCP`SYN报文段`的序号字段中。
  该报文段会被封装在一个IP数据报中，并发送给服务器。

- 第二步：服务器端接受到数据报后，向客户端发送**SYNACK报文段**(SYNACK segment)
  服务器从接收到的数据报中提取出TCP`SYN报文段`，为该TCP连接分配TCP缓存和变量，并向该客户TCP发送允许连接的报文段。
  在报文段的首部包含3个重要信息：**SYN**比特被置为1；**确认号字段ack**被置为`client_isn + 1`；服务器选择自己的**初始序号**(`server_isn`)。
  我收到了你发起建立连接的SYN分组，该分组带有初始序号`client_isn`。我同意建立该连接，我自己的初始序号为`server_isn`。

- 第三步：收到SYNACK报文段后，客户端向服务器端发送报文段，**对服务器的允许连接的报文段进行确认**。
  **确认号**字段`ack`被置为`server_isn + 1`，初始序号被置为`client_isn + 1`。**因为连接已经建立了，所以SYN比特被置为0**。

一旦完成这3个步骤，客户和服务器主机就可以相互发送包括数据的报文段了。在以后每一个报文段中，SYN比特都将被置为0。 



### 问题

- **为何不直接在第一次握手就带上报文段消息，非要第三次才可以带？**

    因为<font color=red>TCP是要保证数据的不丢失且可靠</font>，如果在第一次就带上报文段消息，此次建立连接很有可能就会失败，那么就**不能保证数据的不丢失**了，在不可靠的机制上进行这种操作，换来的代价太大，每次发送报文段的资源也会增大，得不偿失；

    而**第三次握手的时候，客户端已经知道服务器端准备好了**，所以只要告诉服务器端自己准备好了就okay了，所以此时带上报文段信息没有任何问题。

- **可不可以只握手两次？**

    不可以，主要<font color=red>防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误</font>。
    
    三次握手主要是解决这样一个常见的问题，客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了，由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时**重新向服务器发送这条报文**，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。此时<font color=red>此前滞留的那一次请求连接，网络通畅了到达了服务器，**这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接**，这将导致不必要的错误和资源的浪费</font>。

    如果采用的是三次握手，就算是那一次失效的报文传送过来了，**服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认**。<font color=red>由于**服务器收不到确认**，就知道客户端并没有请求连接</font>。


## TCP连接的释放（四次挥手）

<div align=center><img src=Pictures/四次挥手.gif></div>

数据传输完毕后，双方都可释放连接。最开始的时候，客户端和服务器都是处于`ESTABLISHED`状态，然后客户端主动关闭，服务器被动关闭。

1.  `客户端进程`发出**连接释放报文**，<font color=red>告诉服务器端，客户端需要关闭了</font>，并且停止发送数据。释放数据报文首部，**FIN=1**，其**序列号**为`seq=u`（<font color=red>等于前面已经传送过来的数据的最后一个字节的序号加1</font>），此时，客户端进入`FIN-WAIT-1`（**终止等待1**）状态。 TCP规定，<font color=red>`FIN报文段`即使不携带数据，也要消耗一个序号</font>。

2. `服务器`收到连接释放报文，发出**确认报文**，<font color=red>告诉客户端收到了客户端要关闭的消息了</font>，**ACK=1，ack=u+1**，并且带上自己的**序列号seq=v**，此时，服务端就进入了`CLOSE-WAIT`（关闭等待）状态。<font color=red>TCP服务器通知高层的应用进程，进程需要关闭连接了</font>，这时候处于**半关闭状态**，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个`CLOSE-WAIT`状态持续的时间。

3. `客户端`收到服务器的确认请求后，此时，客户端就进入`FIN-WAIT-2`（**终止等待2**）状态，等待服务器发送`连接释放报文`（在这之前还需要接受<font color=red>服务器发送的最后的数据</font>）。

4. `服务器`将<font color=red>最后的数据</font>发送完毕后，就向客户端发送**连接释放报文**，<font color=red>告知客户端，服务器端现在要关闭了</font>，`FIN=1`，`ack=u+1`，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为`seq=w`，此时，服务器就进入了`LAST-ACK`（最后确认）状态，等待客户端的确认。

5. `客户端`收到服务器的连接释放报文后，必须**发出确认**，<font color=red>告知服务器端，客户端已经知道了你准备好关闭了</font>，`ACK=1`，`ack=w+1`，而自己的序列号是`seq=u+1`，此时，客户端就进入了`TIME-WAIT`（**时间等待**）状态。注意**此时TCP连接还没有释放，必须经过`2*MSL`（最长报文段寿命——最长报文段传输时间）的时间后**，当客户端`撤销相应的TCB`后，才进入`CLOSED`状态。
  
6. `服务器`只要收到了客户端发出的确认，立即进入`CLOSED`状态。同样，`撤销TCB`后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。


<div align=center><img src=Pictures/四次挥手.jpg></div>

<div align=center><img src=Pictures/四次挥手.webp width=70%></div>

四次挥手过程只涉及了两种报文，分别是FIN和ACK：

- FIN就是结束连接的意思，谁发出FIN报文，就表示它将不会再发送任何数据，关闭这一方向上的传输通道；

- ACK就是确认的意思，用来通知对方：你方的发送通道已经关闭。

每个方向都需要一个FIN和一个ACK，因此通常被称为四次挥手。这里一点需要注意是：**主动关闭连接的，才有TIME_WAIT状态**。


### TIME_WAIT

当收到被动方发来的FIN报文后，主动方会立刻回复ACK，表示确认对方的发送通道已经关闭，接着就处于TIME_WAIT状态。

TIME_WAIT状态的连接，在主动方看来确实快已经关闭了。然后，被动方没有收到ACK报文前，还是处于LAST_ACK状态。

TIME-WAIT的状态尤其重要，主要是两个原因：

- 防止具有相同「四元组」的**旧数据包被收到**；

- 保证「被动关闭连接」的一方能被正确的关闭，即**保证最后的ACK能让被动关闭方接收，从而帮助其正常关闭**。

**原因一：防止旧连接的数据包**

TIME-WAIT的一个作用是**防止收到历史数据，从而导致数据错乱**的问题。

假设TIME-WAIT没有等待时间或时间过短，被延迟的数据包抵达后会发生什么呢？

<div align=center><img src=Pictures\接收到历史数据的异常.webp></div>

上图黄色框框，服务端在关闭连接之前发送的SEQ = 301报文，被网络延迟了。这时有相同端口的TCP连接被复用后，被延迟的SEQ = 301抵达了客户端，那么客户端是有可能正常接收这个过期的报文，这就会产生数据错乱等严重的问题。

所以，TCP就设计出了这么一个机制，**经过2MSL这个时间，足以让两个方向上的数据包都被丢弃，使得原来连接的数据包在网络中都自然消失，再出现的数据包一定都是新建立连接所产生的**。


**原因二：保证连接正确关闭**

TIME-WAIT的另外一个作用是**等待足够的时间以确保最后的ACK能让被动关闭方接收，从而帮助其正常关闭**。

假设TIME-WAIT没有等待时间或时间过短，断开连接会造成什么问题呢？

<div align=center><img src=Pictures\没有确保正常断开的异常.webp></div>


上图红色框框客户端四次挥手的最后一个ACK报文如果在网络中被丢失了，此时如果客户端TIME-WAIT过短或没有，则就直接进入了CLOSE状态了，那么服务端则会一直处在LASE-ACK状态。

当客户端发起建立连接的SYN请求报文后，服务端会发送RST报文给客户端，连接建立的过程就会被终止。

MSL全称是`Maximum Segment Lifetime`，它定义了**一个报文在网络中的最长生存时间**（**报文每经过一次路由器的转发，IP头部的TTL字段就会减1，减到0时报文就被丢弃，这就限制了报文的最长存活时间**）。

**为什么是2MSL的时长呢？**

这其实是相当于**至少允许报文丢失一次**。比如，若ACK在一个MSL内丢失，这样被动方重发的FIN会在第2个MSL内到达，TIME_WAIT状态的连接可以应对。

**为什么不是4或者8MSL的时长呢？**

你可以想象一个丢包率达到百分之一的糟糕网络，**连续两次丢包的概率只有万分之一，这个概率实在是太小了，忽略它比解决它更具性价比**。

因此，TIME_WAIT和FIN_WAIT2状态的最大时长都是2MSL，由于在Linux系统中，MSL的值固定为30秒，所以它们都是60秒。


### 问题

1. 为何不能三次挥手呢？
    首先如果去掉最后一次挥手，那么服务器端就不知道自己要关闭的报文有没有传输成功，可能半路上就失败了，但是此时客户端不知道，导致客户端一直在等待服务器关闭，但是此时服务器端直接就关闭了；
    
    如果中间的两次挥手合并，那是肯定不行的，因为此时服务器端可能还有很多报文未处理完，此时直接关闭肯定会对传输有很大影响。

2. 为什么客户端在收到服务器端发来的FIN包后要等2个最长报文段传输时间？
   防止最后自己发去的`ack`没传送到服务器，如果服务器没收到客户端的`ack`，肯定会选择重发一次`FIN`包，那么此时如果客户端已经关闭了，客户端就不能再发`ack`确认收到了。至于为何是2个报文段传输时间，因为刚好一去一回嘛… 2个最长报文传输时间没有FIN包发来，就说明服务器已经关闭了，客户端也就可以安心关闭了。

3. 为什么建立连接是三次握手，关闭连接确是四次挥手呢？
    建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。

    而关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送，从而导致多了一次。

4. 如果已经建立了连接，但是客户端突然出现故障了怎么办？
    TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。


## TCP状态

客户端TCP状态：
<div align=center><img src=Pictures/客户端TCP状态.jpg></div>

客户中的TCP向服务器中的TCP发送一个**SYN报文段**。在发送过SYN报文段后，客户TCP进入了**SYN_SENT状态**。 当客户TCP处在SYN_SENf状态时，它**等待来自服务器TCP的对客户所发报文段进行确认且SYN比特被置为1的一个报文段**。收到这样一个报文段之后，客户TCP进入**ESTABIJSHED**(已建立)状态。当处在ESTABIJSHED状态时，TCP客户就能发送和接收包含有效载荷数据(即应用层产生的数据)的TCP报文段了。

客户应用程序决定要关闭该连接，客户TCP发送一个带有FIN比特被置为1的TCP报文段，并进入**FIN_WAIT_1**状态。当处在FIN_WAIT_l状态时，客户TCP等待一个来自服务器的带有确认的TCP报文段。当它收到该报文段时，客户TCP进入**FIN_WAIT_2**状态。 当处在FIN_WAIT_2状态时，客户等待 来自服务器的FIN比特被置为1的另一个报文段；当收到该报文段后，客户TCP对服务器的报文段进行确认，并进入**TIME_WAIT**状态。假定ACK丢失，TIME_WAIT状态使TCP客户重传最后的确认报文。在TIME_WAIT状态中所消耗的时间是与具体实现有关的，而典型的值是30秒、1分钟或2分钟。经过等待后，连接就正式关闭，客户端所有资源（包括端口号）将被释放。

服务器端TCP状态：
<div align=center><img src=Pictures/服务器端TCP状态.jpg></div>







