# Java四种引用方式

| 引用类型 | GC时JVM内存充足 | GC时JVM内存不足 |
|:--------:|:---------------:|:---------------:|
|  强引用  |     不被回收    |     不被回收    |
|  弱引用  |      被回收     |      被回收     |
|  软引用  |     不被回收    |      被回收     |
|  虚引用  |         |           |

https://juejin.im/post/5a5129f5f265da3e317dfc08

https://blog.csdn.net/Light_makeup/article/details/107301647

https://www.cnblogs.com/mfrank/p/10154535.html

Java的内存回收不需要程序员负责，JVM会在必要时启动Java GC完成垃圾回收。Java以便我们**控制对象的生存周期**，提供给了我们四种引用方式，引用强度从强到弱分别为：强引用、软引用、弱引用、虚引用。

## 内存泄漏与内存溢出

- 内存泄露本意是**申请的内存空间没有被正确释放**，导致**后续程序里这块内存被永远占用**（不可达），而且**指向这块内存空间的指针不再存在时，这块内存也就永远不可达了**，内存空间就这么一点点被蚕食——**内存申请后，用完没有释放，造成可用内存越来越少**。
  - 比如有10张纸，本来一人一张，画完自己擦了还回去，别人可以继续画，现在有个坏蛋要了纸不擦不还，然后还跑了找不到人了，如此就只剩下9张纸给别人用了，这样的人多起来后，最后大家一张纸都没有了。
  
- 内存溢出是指**存储的数据超出了指定空间的大小**，这时数据就会越界
  - 常见的溢出，是指在栈空间里，分配了超过数组长度的数据，导致多出来的数据覆盖了栈空间其他位置的数据，这种情况发生时，可能会导致程序出现各种难排查的异常行为，或是被有心人利用，修改特定位置的变量数据达到溢出攻击的目的。
  - Java中的内存溢出，一般指(OOM)这种Error，它更像是一种内存空间不足时发生的错误，并且也不会导致溢出攻击这种问题


## 为什么需要回收

**每一个Java程序中的对象都会占用一定的计算机资源**，最常见的，如：每个对象都会在堆空间上申请一定的内存空间。但是除了内存之外，对象还会占用其它资源，如文件句柄，端口，socket等等。**当你创建一个对象的时候，必须保证它在销毁的时候会释放它占用的资源，防止内存泄露。否则程序将会在OOM中结束它的使命**。

在Java中不需要程序员来管理内存的分配和释放，Java有自动进行内存管理的神器——垃圾回收器，**垃圾回收器会自动回收那些不再使用的对象**。

在Java中，不必像C或者C++那样显式去释放内存，不需要了解其中回收的细节，也不需要担心会将同一个对象释放两次而导致内存损坏。所有这些，垃圾回收器都自动帮你处理好了。你只需要保证那些不再被使用的对象的所有引用都已经被释放掉了，否则，你的程序就会像在C++中那样结束在内存泄漏中。

虽然垃圾回收器确实让Java中的内存管理比C、C++中的内存管理容易许多，但是你不能对于内存完全不关心。如果你不清楚JVM到底会在什么条件下才会对对象进行回收，那么就有可能会不小心在代码中留下内存泄漏的bug。

因此，关注对象的回收时机，理解JVM中垃圾收集的机制，可以提高对于这个问题的敏感度，也能在发生内存泄漏问题时更快的定位问题所在。


## 为什么需要引用类型

引用类型是与JVM密切合作的类型，有些引用类型甚至允许在其引用对象在程序中仍需要的时候被JVM释放。

那么，为什么需要这些引用类型呢？

**在Java中，垃圾回收器线程一直在默默的努力工作着，但你却无法在代码中对其进行控制。无法要求垃圾回收器在精确的时间点对某些对象进行回收**。

**有了这些引用类型之后，可以一定程度上增加对垃圾回收的粒度把控，可以让垃圾回收器在更合适的时机回收掉那些可以被回收掉的对象，而并不仅仅是只回收不再使用的对象**。

这些引用类型各有特点，各有各的适用场景，清楚的了解和掌握它们的用法可以帮助你写出更加健壮的代码。



## 强引用

StrongReference是Java的**默认引用形式**，使用时不需要显示定义。任何通过强引用所使用的对象不管系统资源有多紧张，Java虚拟机宁愿抛出`OutOfMemoryError`错误，使程序异常终止，Java GC都**不会主动回收具有强引用的对象**。

强引用：`A a = new A()`

```java
/**
 * 强引用
 * @author Chenzf
 * @date 2020/07/27
 */

public class StrongReferenceTest {
    public static int M = 1024*1024;

    public static void printlnMemory(String tag) {
        Runtime runtime = Runtime.getRuntime();
        int M = StrongReferenceTest.M;
        System.out.println("\n" + tag + ":");
        System.out.println(runtime.freeMemory()/M + "M(free)/" + runtime.totalMemory()/M + "M(total)");
    }

    public static void main(String[] args) {
        StrongReferenceTest.printlnMemory("1.原可用内存和总内存");

        //实例化10M的数组并与strongReference建立强引用
        byte[] strongReference = new byte[10 * StrongReferenceTest.M];
        StrongReferenceTest.printlnMemory("2.实例化10M的数组，并建立强引用");
        System.out.println("strongReference : " + strongReference);

        System.gc();
        StrongReferenceTest.printlnMemory("3.GC后");
        System.out.println("strongReference : " + strongReference);

        // strongReference = null;后，强引用断开了
        strongReference = null;
        StrongReferenceTest.printlnMemory("4.强引用断开后");
        System.out.println("strongReference : " + strongReference);

        System.gc();
        StrongReferenceTest.printlnMemory("5.GC后");
        System.out.println("strongReference : " + strongReference);
    }
}
```

```
D:\WinSoftware\Java1.8\jdk1.8.0_65\bin\java.exe

1.原可用内存和总内存:
13M(free)/15M(total)

2.实例化10M的数组，并建立强引用:
3M(free)/15M(total)
strongReference : [B@10bedb4

3.GC后:
14M(free)/25M(total)
strongReference : [B@10bedb4

4.强引用断开后:
14M(free)/25M(total)
strongReference : null

5.GC后:
24M(free)/25M(total)
strongReference : null

Process finished with exit code 0
```

<div align=center><img src=Pictures\StrongReference.png></div>


强引用过多的例子：

```java {.line-numbers highlight=5-7}
import java.util.ArrayList;
import java.util.List;

public class StrongReference {
    // 使用静态集合对象来存储并且在代码中随处使用它们
    // 但是这样，就会阻止垃圾回收器对集合中的对象进行回收和销毁。
    // 从而可能导致OOM的发生
    public static List<Integer> cachedObjs = new ArrayList<>();

    public static void main(String[] args) {
        for (int i = 0; i < 100_000_000; i++) {
            cachedObjs.add(i);
        }
    }
}

/*
Output:
Exception: java.lang.OutOfMemoryError thrown from the UncaughtExceptionHandler in thread "main"
*/
```


### 总结

- 强引用就是最普通的引用
- 可以使用强引用直接访问目标对象
- 强引用指向的对象在任何时候都不会被系统回收
- 强引用可能会导致**内存泄漏**
- 过多的强引用会导致**OOM**——内存溢出





## 弱引用

如果一个对象只具有弱引用，**无论内存充足与否，Java GC后对象如果只有弱引用将会被自动回收**。

```java
import java.lang.ref.WeakReference;

/**
 * 弱引用
 * @author Chenzf
 * @date 2020/07/27
 */

public class WeakReferenceTest {
    public static int M = 1024*1024;

    public static void printlnMemory(String tag) {
        Runtime runtime = Runtime.getRuntime();
        int M = WeakReferenceTest.M;
        System.out.println("\n" + tag + ":");
        System.out.println(runtime.freeMemory()/M + "M(free)/" + runtime.totalMemory()/M + "M(total)");
    }

    public static void main(String[] args) {
        WeakReferenceTest.printlnMemory("1.原可用内存和总内存");

        //创建弱引用
        WeakReference<Object> weakRerference = new WeakReference<>(new byte[10 * WeakReferenceTest.M]);
        WeakReferenceTest.printlnMemory("2.实例化10M的数组，并建立弱引用");
        System.out.println("weakRerference.get() : " + weakRerference.get());

        System.gc();
        StrongReferenceTest.printlnMemory("3.GC后");
        System.out.println("weakRerference.get() : " + weakRerference.get());
    }
}
```

``` {.line-numbers highlight=8-10}
1.原可用内存和总内存:
13M(free)/15M(total)

2.实例化10M的数组，并建立弱引用:
3M(free)/15M(total)
weakRerference.get() : [B@10bedb4

3.GC后:
14M(free)/15M(total)
weakRerference.get() : null

Process finished with exit code 0
```

## 软引用

软引用和弱引用的特性基本一致，主要的区别在于软引用在内存不足时才会被回收。**如果一个对象只具有软引用，Java GC在内存充足的时候不会回收它，内存不足时才会被回收**。

垃圾回收器会在内存不足，经过一次垃圾回收后，内存仍旧不足的时候回收掉软可达对象。在虚拟机抛出OOM(`OutOfMemoryError`)之前，会保证已经清除了所有指向软可达对象的软引用。

如果内存足够，并没有规定回收软引用的具体时间，所以在内存充足的情况下，软引用对象也可能存活很长时间。



```java
import java.lang.ref.SoftReference;

/**
 * 软引用
 * @author Chenzf
 * @date 2020/07/27
 * @version 1.0
 */

public class SoftReferenceTest {

    public static int M = 1024 * 1024;

    public static void printlnMemory(String tag) {
        Runtime runtime = Runtime.getRuntime();
        int M = StrongReferenceTest.M;
        System.out.println("\n" + tag + ":");
        System.out.println(runtime.freeMemory()/M + "M(free)/" + runtime.totalMemory()/M + "M(total)");
    }

    public static void main(String[] args) {
        SoftReferenceTest.printlnMemory("1.原可用内存和总内存");

        //建立软引用
        SoftReference<Object> softRerference = new SoftReference<>(new byte[10 * SoftReferenceTest.M]);
        SoftReferenceTest.printlnMemory("2.实例化10M的数组，并建立软引用");
        System.out.println("softRerference.get() : " + softRerference.get());

        System.gc();
        SoftReferenceTest.printlnMemory("3.内存可用容量充足，GC后");
        System.out.println("softRerference.get() : " + softRerference.get());

        //实例化一个4M的数组,使内存不够用,并建立软引用
        //free=10M=4M+10M-4M,证明内存可用量不足时，GC后byte[10*m]被回收
        SoftReference<Object> softRerference2 = new SoftReference<>(new byte[170 * SoftReferenceTest.M]);
        SoftReferenceTest.printlnMemory("4.实例化一个170M的数组后");
        System.out.println("softRerference.get() : " + softRerference.get());
        System.out.println("softRerference2.get() : " + softRerference2.get());
    }
}
```

``` {.line-numbers highlight=12-15}
1.原可用内存和总内存:
13M(free)/15M(total)

2.实例化10M的数组，并建立软引用:
3M(free)/15M(total)
softRerference.get() : [B@10bedb4

3.内存可用容量充足，GC后:
14M(free)/25M(total)
softRerference.get() : [B@10bedb4

4.实例化一个170M的数组后:
75M(free)/247M(total)
softRerference.get() : null
softRerference2.get() : [B@103dbd3

Process finished with exit code 0
```

### 应用场景

软引用很适合用来实现**缓存**：比如网页缓存、图片缓存等。

在很多应用中，都会出现大量的默认图片，比如说QQ的默认头像，应用内的默认图标等等，这些图片很多地方会用到。

**如果每次都去读取图片，由于读取文件速度较慢，大量重复的读取会导致性能下降**。所以可以考虑将图片缓存起来，**需要的时候直接从<font color=red>内存</font>中读取**。但是，由于图片占用内存空间比较大，**缓存的图片过多会占用比较多的内存**，就可能比较容易发生OOM。这时候，软引用就派得上用场了。


### 总结

- 软引用弱于强引用
- 软引用指向的对象会**在内存不足时被垃圾回收清理掉**
- JVM会**优先回收长时间闲置不用的软引用对象**，对那些刚刚构建的或刚刚使用过的软引用对象会尽可能保留
- 软引用可以有效的**解决OOM问题**
- 软引用适合用作**非必须大对象的缓存**


## 虚引用 PhantomReference

从PhantomReference类的源代码可以知道，**它的`get()`方法无论何时返回的都只会是null。所以单独使用虚引用时，没有什么意义，需要和引用队列`ReferenceQueue`类联合使用**。**当执行Java GC时如果一个对象只有虚引用，就会把这个对象加入到与之关联的`ReferenceQueue`中**。

它的作用在于**跟踪垃圾回收过程**，在对象被收集器回收时收到一个系统通知。 

当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在垃圾回收后，**将这个虚引用加入引用队列，在其关联的虚引用出队前，不会彻底销毁该对象**。 

所以可以通过检查引用队列中是否有相应的虚引用来**判断对象是否已经被回收了——作为对象是否存活的监控**。

```java
import java.lang.ref.PhantomReference;
import java.lang.ref.ReferenceQueue;

/**
 * 虚引用
 * @author Chenzf
 * @date 2020/07/27
 * @version 1.0
 */

public class PhantomReferenceTest {

    public static int M = 1024*1024;

    public static void printlnMemory(String tag){
        Runtime runtime = Runtime.getRuntime();
        int M = PhantomReferenceTest.M;
        System.out.println("\n" + tag + ":");
        System.out.println(runtime.freeMemory()/M + "M(free)/" + runtime.totalMemory()/M + "M(total)");
    }

    public static void main(String[] args) throws InterruptedException {

        PhantomReferenceTest.printlnMemory("1.原可用内存和总内存");

        byte[] object = new byte[10 * PhantomReferenceTest.M];
        PhantomReferenceTest.printlnMemory("2.实例化10M的数组后");

        //建立虚引用
        ReferenceQueue<Object> referenceQueue = new ReferenceQueue<>();
        PhantomReference<Object> phantomReference = new PhantomReference<>(object, referenceQueue);

        PhantomReferenceTest.printlnMemory("3.建立虚引用后");
        System.out.println("phantomReference : " + phantomReference);
        System.out.println("phantomReference.get() : " + phantomReference.get());
        System.out.println("referenceQueue.poll() : " + referenceQueue.poll());

        //断开byte[10*PhantomReferenceTest.M]的强引用
        object = null;
        PhantomReferenceTest.printlnMemory("4.执行object = null;强引用断开后");

        System.gc();
        PhantomReferenceTest.printlnMemory("5.GC后");
        System.out.println("phantomReference : " + phantomReference);
        System.out.println("phantomReference.get() : " + phantomReference.get());
        System.out.println("referenceQueue.poll() : " + referenceQueue.poll());

        //断开虚引用
        phantomReference = null;
        System.gc();
        PhantomReferenceTest.printlnMemory("6.断开虚引用后GC");
        System.out.println("phantomReference : " + phantomReference);
        System.out.println("referenceQueue.poll() : " + referenceQueue.poll());
    }
}
```

```java
import java.lang.ref.PhantomReference;
import java.lang.ref.ReferenceQueue;

/**
 * 虚引用
 * @author Chenzf
 * @date 2020/07/27
 * @version 1.0
 */

public class PhantomReferenceTest {

    public static int M = 1024 * 1024;

    public static void printlnMemory(String tag){
        Runtime runtime = Runtime.getRuntime();
        int M = PhantomReferenceTest.M;
        System.out.println("\n" + tag + ":");
        System.out.println(runtime.freeMemory()/M + "M(free)/" + runtime.totalMemory()/M + "M(total)");
    }

    public static void main(String[] args) throws InterruptedException {

        PhantomReferenceTest.printlnMemory("1.原可用内存和总内存");

        byte[] object = new byte[10 * PhantomReferenceTest.M];
        PhantomReferenceTest.printlnMemory("2.实例化10M的数组后");

        //建立虚引用
        ReferenceQueue<Object> referenceQueue = new ReferenceQueue<>();
        PhantomReference<Object> phantomReference = new PhantomReference<>(object, referenceQueue);

        PhantomReferenceTest.printlnMemory("3.建立虚引用后");
        System.out.println("phantomReference : " + phantomReference);
        System.out.println("phantomReference.get() : " + phantomReference.get());
        System.out.println("referenceQueue.poll() : " + referenceQueue.poll());

        //断开byte[10*PhantomReferenceTest.M]的强引用
        object = null;
        PhantomReferenceTest.printlnMemory("4.执行object = null;强引用断开后");

        System.gc();
        PhantomReferenceTest.printlnMemory("5.GC后");
        System.out.println("phantomReference : " + phantomReference);
        System.out.println("phantomReference.get() : " + phantomReference.get());
        System.out.println("referenceQueue.poll() : " + referenceQueue.poll());

        //断开虚引用
        phantomReference = null;
        System.gc();
        PhantomReferenceTest.printlnMemory("6.断开虚引用后GC");
        System.out.println("phantomReference : " + phantomReference);
        System.out.println("referenceQueue.poll() : " + referenceQueue.poll());
    }
}
```

- PhantomReference的`get()`方法无论何时返回的都只会是null。
- 当执行Java GC时如果一个对象只有虚引用，就会把这个对象加入到与之关联的`ReferenceQueue`中。

```
1.原可用内存和总内存:
13M(free)/15M(total)

2.实例化10M的数组后:
3M(free)/15M(total)

3.建立虚引用后:
3M(free)/15M(total)
phantomReference : java.lang.ref.PhantomReference@10bedb4
phantomReference.get() : null
referenceQueue.poll() : null

4.执行object = null;强引用断开后:
3M(free)/15M(total)

5.GC后:
14M(free)/25M(total)
phantomReference : java.lang.ref.PhantomReference@10bedb4
phantomReference.get() : null
referenceQueue.poll() : java.lang.ref.PhantomReference@10bedb4

6.断开虚引用后GC:
24M(free)/25M(total)
phantomReference : null
referenceQueue.poll() : null

Process finished with exit code 0
```


## 可达性

不同的引用类型其实都是逻辑上的，而对于虚拟机来说，主要体现的是对象的不同的**可达性(reachable)状态**和**对垃圾收集(garbage collector)的影响**。


可以通过下面的流程来对对象的生命周期做一个总结：

<div align=center><img src=Pictures\对象的生命周期.png></div>

对象被创建并初始化，对象在运行时被使用，然后离开对象的作用域，对象会变成不可达并会被垃圾收集器回收。图中**用红色标明的区域表示对象处于强可达阶段**。

如果只讨论**符合垃圾回收条件的对象**，那么只有三种：软可达、弱可达和虚可达。

- 软可达：只能通过软引用才能访问的状态，软可达的对象是由`SoftReference`引用的对象，并且没有强引用的对象。
    - 软引用是用来描述一些**还有用但是非必须的对象**。
    - 垃圾收集器会尽可能长时间的保留软引用的对象，但是会在发生`OutOfMemoryError`之前，回收软引用的对象。如果回收完软引用的对象，内存还是不够分配的话，就会直接抛出`OutOfMemoryError`。

- 弱可达：弱可达的对象是`WeakReference`引用的对象。
    - 垃圾收集器可以**随时收集弱引用的对象，不会尝试保留软引用的对象**。

- 虚可达：虚可达是由`PhantomReference`引用的对象，虚可达就是没有强、软、弱引用进行关联，并且已经被`finalize`过了，只有虚引用指向这个对象的时候。


除此之外，还有强可达和不可达的两种可达性判断条件

- 强可达：就是一个对象刚被创建、初始化、使用中的对象都是处于强可达的状态

- 不可达(unreachable)：处于不可达的对象就意味着对象可以被清除了。

不同可达性状态的转换图：

<div align=center><img src=Pictures\可达性状态转换图.png width=70%></div>


## 总结

- 强引用是Java的默认引用形式，使用时不需要显示定义，是我们平时最常使用到的引用方式。**不管系统资源有多紧张，Java GC都不会主动回收具有强引用的对象**。 

- 弱引用和软引用一般在引用对象为非必需对象的时候使用，它们的区别是
    - **被弱引用关联的对象在垃圾回收时总是会被回收**
    - **被软引用关联的对象只有在内存不足时才会被回收**。 

- 虚引用的get()方法获取的永远是null，无法获取对象实例。**Java GC会把虚引用的对象放到引用队列里面**。可用来在对象被回收时做额外的一些资源清理或事物回滚等处理。 

由于无法从虚引获取到引用对象的实例。它的使用情况比较特别，所以这里不把虚引用放入表格进行对比。这里对强引用、弱引用、软引用进行对比：

| 引用类型 | GC时JVM内存充足 | GC时JVM内存不足 |
|:--------:|:---------------:|:---------------:|
|  强引用  |     不被回收    |     不被回收    |
|  弱引用  |      被回收     |      被回收     |
|  软引用  |     不被回收    |      被回收     |

设置四种引用类型，是为了更好的**控制对象的生命周期**，让代码能够一定程度上干涉GC过程，所以引用类型主要就是跟垃圾回收有关了。

对于JVM、GC和内存，可以这样理解，**内存**好比你的**抽屉**，这个抽屉有一定大小，并不能无限存放东西。

**JVM**好比**你自己**，会时不时来整理抽屉。那些申请的对象好比放在抽屉里的东西，生活中的必需品就好比强引用，而那些可能用到的东西（非必需品）就好比软引用或者弱引用。

当抽屉还很空的时候，放一些非必须品你也不会在意，但是随着买的东西越来越多，抽屉里快放不下的时候，就需要根据重要程度来选择一些东西扔出抽屉，这个过程就好比GC。

JVM在内存够用的时候，不会对软引用的对象进行回收，但是当内存紧张的时候，就会对它们进行清理。

| 引用类型 | 引用对象被垃圾回收的时间                        | 用途                                       | 是否可以转为强引用 | 对应的类                  |
|----------|-------------------------------------------------|--------------------------------------------|--------------------|---------------------------|
| 强引用   | 从来不会                                        | 一般用途，保持对象不被回收                 | 可以               | 默认                      |
| 软引用   | 发生一次GC后，JVM决定还需要进一步回收更多空间时 | 缓存，保持对象在内存足够时不被回收         | 可以               | SoftReference             |
| 弱引用   | 进行垃圾回收时，如果对象只存在弱引用            | 缓存，仅仅在对象仍被使用时保持其不被回收   | 可以               | WeakReference WeakHashMap |
| 虚引用   | 进行垃圾回收时                                  | 跟踪GC过程，在对象被回收前进行一些清理工作 | 不可以             | PhantomReference          |


# 什么是垃圾回收

垃圾回收（Garbage Collection，GC），顾名思义就是**释放垃圾占用的空间，防止内存泄露**。有效的使用可以使用的内存，对内存堆中已经死亡的或者长时间没有使用的对象进行清除和回收。

## 哪些内存需要被回收

对象是否可以被回收的两种经典算法：**引用计数法**和**可达性分析算法**。

### Stop-the-World

- Stop-the-World意味着**JVM由于要执行GC而停止了应用程序的执行**，并且这种情形会在任何一种GC算法中发生。
- **当Stop-the-World发生时，除了GC所需的线程以外，所有线程都处于等待状态直到GC任务完成**。
- 事实上，GC优化很多时候就是指**减少Stop-the-World发生的时间**，从而使系统具有高吞吐、低停顿的特点。

### 引用计数法

引用计数算法(Reachability Counting)是**通过在对象头中分配一个空间来保存该对象被引用的次数**(Reference Count)。
- 如果该对象被其它对象引用，则它的引用计数加1；
- 如果删除对该对象的引用，那么它的引用计数就减1；
- 当该对象的引用计数为0时，那么该对象就会被回收。

**引用计数算法是将垃圾回收分摊到整个应用程序的运行当中了**，而不是在进行垃圾收集时，要挂起整个应用的运行，直到对堆中所有对象的处理都结束。因此，**采用引用计数的垃圾收集不属于严格意义上的"Stop-The-World"的垃圾收集机制**。

**引用计数收集器可以很快的执行，并且交织在程序运行中，对程序需要不被长时间打断的实时环境比较有利，但其很难解决对象之间相互循环引用的问题**。

如下面的程序和示意图所示，对象objA和objB之间的引用计数永远不可能为 0，那么这两个对象就永远不能被回收：

<div align=center><img src=Pictures\引用计数.png></div>

```java
public class ReferenceCountingGC {
    public Object instance = null;

    public static void testGC(){

        ReferenceCountingGC objA = new ReferenceCountingGC ();
        ReferenceCountingGC objB = new ReferenceCountingGC ();

        // 对象之间相互循环引用，对象objA和objB之间的引用计数永远不可能为 0
        objB.instance = objA;
        objA.instance = objB;

        objA = null;
        objB = null;

        System.gc();
    }
}
```

上述代码最后面两句将objA和objB赋值为null，也就是说objA和objB指向的对象已经不可能再被访问，但是由于它们互相引用对方，导致它们的引用计数器都不为 0，那么垃圾收集器就永远不会回收它们。

### 可达性分析算法：判断对象的引用链是否可达

可达性分析算法是通过判断对象的引用链是否可达来决定对象是否可以被回收。

可达性分析算法（Reachability Analysis）的基本思路是，**通过一些被称为引用链（GC Roots）的对象作为起点，从这些节点开始向下搜索，搜索走过的路径被称为（Reference Chain)，当一个对象到 GC Roots 没有任何引用链相连时（即从 GC Roots 节点到该节点不可达），则证明该对象是不可用的**。

<div align=center><img src=Pictures\可达性分析.jpeg></div>

通过可达性算法，**成功解决了引用计数所无法解决的问题-“循环依赖”，只要你无法与 GC Root 建立直接或间接的连接，系统就会判定你为可回收对象**。

那这样就引申出了另一个问题，**哪些属于 GC Root**。


在 Java 语言中，可作为 GC Root 的对象包括以下4种：

- 虚拟机栈（栈帧中的本地变量表）中引用的对象
- 方法区中类静态属性引用的对象
- 方法区中常量引用的对象
- 本地方法栈中 JNI（即一般说的 Native 方法）引用的对象

<div align=center><img src=Pictures\Java内存区域.jpeg></div>


## 什么时候回收

堆的新生代、老年代、永久代的垃圾回收时机，MinorGC 和 FullGC

### 内存区域

<div align=center><img src=Pictures\内存区域.jpeg></div>

Java 堆（Java Heap）是JVM所管理的内存中最大的一块，堆又是垃圾收集器管理的主要区域，这里我们主要分析一下 Java 堆的结构。

Java 堆主要分为2个区域：
- 年轻代
    - Eden 区
    - Survivor 区
        - From区
        - To区
- 老年代

#### 新生代

**新生代的目标就是尽可能快速的收集掉那些生命周期短的对象，一般情况下，所有新生成的对象首先都是放在新生代的。**

新生代内存按照 8:1:1 的比例分为一个eden区和两个survivor(survivor0，survivor1)区，**大部分对象在Eden区中生成**。

在进行垃圾回收时
- 先将eden区存活对象复制到survivor0区，然后清空eden区
- 当这个survivor0区也满了时，则将eden区和survivor0区存活对象复制到survivor1区，然后清空eden和这个survivor0区
- 此时survivor0区是空的，然后交换survivor0区和survivor1区的角色（即下次垃圾回收时会扫描Eden区和survivor1区），即保持survivor0区为空，如此往复。
- 特别地，**当survivor1区也不足以存放eden区和survivor0区的存活对象时，就将存活对象直接存放到老年代**。
- **如果老年代也满了，就会触发一次FullGC，也就是新生代、老年代都进行回收**。注意，**新生代发生的GC也叫做MinorGC**，MinorGC发生频率比较高，不一定等 Eden区满了才触发。

#### 老年代

**老年代存放的都是一些生命周期较长的对象**，就像上面所叙述的那样，**在新生代中经历了N次垃圾回收后仍然存活的对象就会被放到老年代中**。

此外，老年代的内存也比新生代大很多(大概比例是1:2)，**当老年代满时会触发Major GC(Full GC)，老年代对象存活时间比较长，因此FullGC发生的频率比较低**。

#### 永久代

永久代主要用于**存放静态文件，如Java类、方法等**。

**永久代对垃圾回收没有显著影响**，但是有些应用可能动态生成或者调用一些class，例如使用反射、动态代理、CGLib等bytecode框架时，在这种时候需要设置一个比较大的永久代空间来存放这些运行过程中新增的类。


### 垃圾回收两种类型

由于对象进行了分代处理，因此垃圾回收区域、时间也不一样。垃圾回收有两种类型，Minor GC 和 Full GC。

- Minor GC：**对新生代进行回收，不会影响到年老代**。因为新生代的 Java 对象大多死亡频繁，所以 Minor GC 非常频繁，一般在这里使用速度快、效率高的算法，使垃圾回收能尽快完成。

- Full GC：也叫 Major GC，**对整个堆进行回收，包括新生代和老年代**。由于Full GC需要对整个堆进行回收，所以比Minor GC要慢，因此应该尽可能减少Full GC的次数，导致Full GC的原因包括：老年代被写满、永久代（Perm）被写满和System.gc()被显式调用等。


## 如何回收

三种经典垃圾回收算法(标记清除算法、复制算法、标记整理算法)及分代收集算法 和 七种垃圾收集器。

在确定了哪些垃圾可以被回收后，垃圾收集器要做的事情就是开始进行垃圾回收，但是这里面涉及到一个问题是：**如何高效地进行垃圾回收**。由于Java虚拟机规范并没有对如何实现垃圾收集器做出明确的规定，因此各个厂商的虚拟机可以采用不同的方式来实现垃圾收集器。

### 标记清除算法

<div align=center><img src=Pictures\标记清除算法.jpeg></div>

标记清除算法（Mark-Sweep）是最基础的一种垃圾回收算法，它分为2部分，**先把内存区域中的这些对象进行标记，哪些属于可回收标记出来，然后把这些垃圾拎出来清理掉**。就像上图一样，清理掉的垃圾就变成未使用的内存区域，等待被再次使用。

这逻辑再清晰不过了，并且也很好操作，但它存在一个很大的问题，那就是**内存碎片**。

上图中等方块的假设是 2M，小一些的是 1M，大一些的是 4M。**等我们回收完，内存就会切成了很多段**。我们知道**开辟内存空间时，需要的是连续的内存区域**，这时候我们需要一个 2M的内存区域，其中有2个 1M 是没法用的。这样就导致，**其实我们本身还有这么多的内存的，但却用不了**。


### 复制算法

<div align=center><img src=Pictures\复制算法.jpeg></div>

复制算法（Copying）是在标记清除算法上演化而来，**解决标记清除算法的内存碎片问题**。
- 它**将可用内存按容量划分为大小相等的两块，每次只使用其中的一块**。
- **当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉**。
- **保证了内存的连续可用**，内存分配时也就不用考虑内存碎片等复杂情况，逻辑清晰，运行高效。

上面的图很清楚，也很明显的暴露了另一个问题，合着我这**140平的大三房，只能当70平米的小两房来使**？代价实在太高。

### 标记整理算法

<div align=center><img src=Pictures\标记整理算法.jpeg></div>

标记整理算法（Mark-Compact）标记过程仍然与标记清除算法一样，**但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，再清理掉端边界以外的内存区域**。

标记整理算法一方面在标记清除算法上做了升级，**解决了内存碎片的问题，也规避了复制算法只能利用一半内存区域的弊端**。看起来很美好，但从上图可以看到，它**对内存变动更频繁，需要整理所有存活对象的引用地址，在效率上比复制算法要差很多**。


### 分代收集算法

分代收集算法（Generational Collection）严格来说并不是一种思想或理论，而是**融合上述3种基础的算法思想，而产生的针对不同情况所采用不同算法的一套组合拳**。

对象存活周期的不同将内存划分为几块。一般是**把 Java 堆分为新生代和老年代**，这样就可以**根据各个年代的特点采用最适当的收集算法**。

- 在**新生代**中，每次垃圾收集时都发现**有大批对象死去，只有少量存活，那就选用复制算法**，只需要付出少量存活对象的复制成本就可以完成收集。
- 而**老年代中因为对象存活率高、没有额外空间对它进行分配担保**，就必须使用**标记清理**或者**标记整理算法**来进行回收。


另一个问题来了，那内存区域到底被分为哪几块，每一块又有什么特别适合什么算法呢？



