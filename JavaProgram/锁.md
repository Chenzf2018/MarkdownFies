参考资料：

https://tech.meituan.com/2018/11/15/java-lock.html

<div align=center><img src=Lock\Lock1.png></div>

# 乐观锁 VS 悲观锁

<div align=center><img src=Lock\并发编程三大核心.png></div>

乐观锁与悲观锁是一种广义上的概念，体现了看待线程同步的不同角度。在Java和数据库中都有此概念对应的实际应用。

- 悲观锁：对于同一个数据的并发操作，悲观锁认为自己**在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改**。
  - Java中，**synchronized关键字**和**Lock的实现类**都是悲观锁。

- 乐观锁：乐观锁认为自己在使用数据时不会有别的线程修改数据，所以不会添加锁，只是**在更新数据的时候去判断之前有没有别的线程更新了这个数据**。
  - 如果这个数据没有被更新，当前线程将自己修改的数据成功写入。
  - 如果数据已经被其他线程更新，则根据不同的实现方式执行不同的操作（例如报错或者自动重试）。
  - 乐观锁在Java中是通过使用**无锁编程**来实现，最常采用的是**CAS算法**，Java原子类中的递增操作就通过CAS自旋实现的。


<div align=center><img src=Lock\Lock2.png></div>

根据从上面的概念描述我们可以发现：

- 悲观锁适合**写操作多**的场景，先加锁可以**保证写操作时数据正确**。
- 乐观锁适合**读操作多**的场景，不加锁的特点能够使其**读操作的性能大幅提升**。


光说概念有些抽象，我们来看下乐观锁和悲观锁的调用方式示例：

```java
// ------------------------- 悲观锁的调用方式 -------------------------
// synchronized
public synchronized void testMethod() {
	// 操作同步资源
}

// ReentrantLock
private ReentrantLock lock = new ReentrantLock(); // 需要保证多个线程使用的是同一个锁
public void modifyPublicResources() {
    lock.lock();
	// 操作同步资源
	lock.unlock();
}

// ------------------------- 乐观锁的调用方式 -------------------------
// 需要保证多个线程使用的是同一个AtomicInteger
private AtomicInteger atomicInteger = new AtomicInteger();  
atomicInteger.incrementAndGet(); //执行自增1
```

- 悲观锁基本都是在**显式的锁定之后再操作同步资源**
- 而乐观锁则**直接去操作同步资源**

那么，为何乐观锁能够做到不锁定同步资源也可以正确的实现线程同步呢？

我们通过介绍**乐观锁的主要实现方式CAS**的技术原理来为大家解惑。

## CAS

**CAS全称Compare And Swap（比较与交换），是一种无锁算法**。在不使用锁（**没有线程被阻塞**）的情况下实现多线程之间的变量同步。`java.util.concurrent`包中的**原子类**就是通过CAS来实现了乐观锁。


### CAS算法涉及到三个操作数

- 需要读写的内存值V。
- 进行比较的值A。
- 要写入的新值B。

**当且仅当V的值等于A时，CAS通过原子方式用新值B来更新V的值**（**“比较+更新”整体是一个原子操作**），否则不会执行任何操作。一般情况下，“更新”是一个不断重试的操作。

之前提到`java.util.concurrent`包中的原子类，就是通过CAS来实现了乐观锁，那么我们进入原子类`AtomicInteger`的源码，看一下`AtomicInteger`的定义：

<div align=left><img src=Lock\Lock3.png></div>

根据定义我们可以看出各属性的作用：

- `unsafe`：获取并操作内存的数据。
- `valueOffset`：存储`value`在`AtomicInteger`中的偏移量。
- `value`：存储`AtomicInteger`的`int`值，该属性需要借助`volatile`关键字**保证其在线程间是可见的**。

接下来，我们查看`AtomicInteger`的自增函数`incrementAndGet()`的源码时，发现自增函数底层调用的是`unsafe.getAndAddInt()`。但是由于JDK本身只有`Unsafe.class`，只通过`class`文件中的参数名，并不能很好的了解方法的作用，所以我们通过`OpenJDK 8`来查看`Unsafe`的源码：

```java
// ------------------------- JDK 8 -------------------------
// AtomicInteger 自增方法
public final int incrementAndGet() {
  return unsafe.getAndAddInt(this, valueOffset, 1) + 1;
}

// Unsafe.class
public final int getAndAddInt(Object var1, long var2, int var4) {
  int var5;
  do {
      var5 = this.getIntVolatile(var1, var2);
  } while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));
  return var5;
}

// ------------------------- OpenJDK 8 -------------------------
// Unsafe.java
public final int getAndAddInt(Object o, long offset, int delta) {
   int v;
   do {
       v = getIntVolatile(o, offset);
   } while (!compareAndSwapInt(o, offset, v, v + delta));
   return v;
}
```

根据`OpenJDK 8`的源码我们可以看出，`getAndAddInt()`循环获取给定对象`o`中的偏移量处的值`v`，然后**判断内存值是否等于`v`**。**如果相等则将内存值设置为**`v + delta`，否则返回`false`，继续循环进行重试，直到设置成功才能退出循环，并且将旧值返回。

整个**比较+更新**操作封装在`compareAndSwapInt()`中，在`JNI`里是借助于一个CPU指令完成的，属于**原子操作**，可以保证多个线程都能够看到同一个变量的修改值。

后续JDK通过CPU的`cmpxchg`指令，去**比较寄存器中的A和内存中的值V**。**如果相等，就把要写入的新值B存入内存中。如果不相等，就将内存值V赋值给寄存器中的值A**。然后通过Java代码中的while循环再次调用cmpxchg指令进行重试，直到设置成功为止。

### CAS三大问题

CAS虽然很高效，但是它也存在三大问题：

- **ABA问题**。
  - CAS需要在操作值的时候检查内存值是否发生变化，没有发生变化才会更新内存值。但是**如果内存值原来是A，后来变成了B，然后又变成了A，那么CAS进行检查时会发现值没有发生变化，但是实际上是有变化的**。
  - ABA问题的解决思路就是**在变量前面添加版本号**，每次变量更新的时候都把版本号加一，**这样变化过程就从“A－B－A”变成了“1A－2B－3A”**。
  - JDK从1.5开始提供了`AtomicStampedReference`类来解决ABA问题，具体操作封装在`compareAndSet()`中。`compareAndSet()`首先检查当前引用和当前标志与预期引用和预期标志是否相等，如果都相等，则以原子方式将引用值和标志的值设置为给定的更新值。

- **循环时间长开销大**。
  - CAS操作如果长时间不成功，会导致其一直自旋，给CPU带来非常大的开销。

- **只能保证一个共享变量的原子操作**。
  - 对一个共享变量执行操作时，CAS能够保证原子操作，但是对多个共享变量操作时，CAS是无法保证操作的原子性的。
  - Java从1.5开始JDK提供了`AtomicReference`类来保证引用对象之间的原子性，可以把多个变量放在一个对象里来进行CAS操作。



## 自旋锁 VS 适应性自旋锁

<div align=center><img src=Lock\Lock1.png></div>

### 自旋锁的概念

阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间。**如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长**。

**在许多场景中，同步资源的锁定时间很短，为了这一小段时间去切换线程，线程挂起和恢复现场的花费可能会让系统得不偿失**。如果物理机器有多个处理器，能够让两个或以上的线程同时并行执行，我们就可以**让后面那个请求锁的线程不放弃CPU的执行时间，看看持有锁的线程是否很快就会释放锁**。

而为了**让当前线程“稍等一下”，我们需让当前线程进行自旋**，**如果在自旋完成后前面锁定同步资源的线程已经释放了锁，那么当前线程就可以不必阻塞而是直接获取同步资源，从而避免切换线程的开销**。这就是自旋锁。

<div align=center><img src=Lock\Lock4.png></div>

自旋锁本身是有缺点的，**它不能代替阻塞**。

自旋等待虽然避免了线程切换的开销，但它**要占用处理器时间**。
- **如果锁被占用的时间很短，自旋等待的效果就会非常好**。
- 反之，**如果锁被占用的时间很长，那么自旋的线程只会白浪费处理器资源**。

所以，自**旋等待的时间必须要有一定的限度**，如果自旋超过了限定次数（默认是10次，可以使用-XX:PreBlockSpin来更改）没有成功获得锁，就应当挂起线程。

**自旋锁的实现原理同样也是CAS**，`AtomicInteger`中调用`unsafe`进行自增操作的源码中的do-while循环就是一个自旋操作，如果修改数值失败则通过循环来执行自旋，直至修改成功。

<div align=center><img src=Lock\Lock5.png></div>

### 适应性自旋锁

自旋锁在JDK1.4.2中引入，使用`-XX:+UseSpinning`来开启。JDK 6中变为默认开启，并且引入了**自适应的自旋锁（适应性自旋锁）**。

自适应意味着**自旋的时间（次数）不再固定**，而是**由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定**。
- 如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为**这次自旋也是很有可能再次成功**，进而它将允许自旋等待持续相对更长的时间。
- 如果对于某个锁，**自旋很少成功获得过**，那在以后尝试获取这个锁时将可能**省略掉自旋过程，直接阻塞线程**，避免浪费处理器资源。

在自旋锁中 另有三种常见的锁形式:`TicketLock`、`CLHlock`和`MCSlock`。

