# 接口
接口和抽象类提供了一种将接口与实现分离的更加结构化的方法。

## 抽象类和方法
建立通用接口的唯一理由是，不同的子类可以用不同的方式表示此接口。

包含`抽象方法`(仅有声明而没有方法体)的类叫做`抽象类`。如果一个类包含一个或多个抽象方法，该类必须被限定为抽象的。否则，编译器就会报错。

如果从一个抽象类继承，并想创建该新类的对象，那么就必须为基类中的所有抽象方法提供方法定义。如果不这样做(可以选择不做)，那么派生类便也是抽象类，且编译器将会强制我们用`abstract`关键字来限定这个类。

```java
abstract class Instrument 
{
    private int i; // Storage allocated for each

    public abstract void play(Note n);
    public abstract void adjust();

    public String what() 
    {
        return "Instrument";
    }
}

class Wind extends Instrument 
{
    @Override
    public void play(Note n) 
    {
        System.out.println("Wind.play() " + n);
    }

    @Override
    public void adjust() 
    {
        System.out.println("Adjusting Wind");
    }

    @Override
    public String what() 
    {
        return "Wind";
    }
}
```

## 创建接口
`abstract`关键字允许人们在类中创建一个或多个没有任何定义的方法——提供了接口部分，但是没有提供任何相应的具体实现，这些实现是由此类的继承者创建的。

`interface`这个关键字产生一个完全抽象的类，它根本就没有提供任何具体实现。它允许创建者确定方法名、参数列表和返回类型，但是没有任何方法体。<font color=red>接口只提供了形式，而未提供任何具体实现</font>。

`interface`不仅仅是一个极度抽象的类，因为它允许人们通过创建一个能够被向上转型为多种基类的类型，来实现某种类似多`重继承`(不借助接口，Java只能`单继承`)的特性。

<font color=red>接口也可以包含属性，但是这些属性隐式地是`static`和`final`的</font>。要让一个类遵循某个特定接口(或者是一组接口)，需要使用`implements`关键字。

接口的典型使用是代表一个类的类型或一个形容词，如`Runnable`或`Serializable`，而抽象类通常是类层次结构的一部分或一件事物的类型，如`String`或`ActionHero`。

```java
package Polymorphism.Music;

public enum  Note
{
    MIDDLE_C, C_SHARP, B_FLAT;
}


package Interface.Music5;

import Polymorphism.Music.Note;

interface Instrument
{
    // Compile-time constant:
    int VALUE = 5;  // static & final

    // Cannot have method definitions:
    void play(Note n);  //Automatically public
    void adjust();
}

class Wind implements Instrument
{
    public void play(Note n){System.out.println(this + ".play() " + n);}
    public void adjust(){System.out.println(this + ".adjust ");}
    public String toString(){return "Wind";}
}

class Percussion implements Instrument
{
    public void play(Note n){System.out.println(this + ".play() " + n);}
    public void adjust(){System.out.println(this + ".adjust()");}
    public String toString(){return "Percussion";}
}

class Stringed implements Instrument
{
    public void play(Note n){System.out.println(this + ".play()" + n);}
    public void adjust(){System.out.println(this + "adjust()");}
    public String toString(){return "Stringed";}
}

class Woowind extends Wind
{
    @Override
    public String toString(){return "Woodwind";}
}

class Brass extends Wind
{
    @Override
    public String toString(){return "Brass";}
}

public class Music5
{
    // Doesn't care about type, so new types added to the system still work right:
    static void tune(Instrument instrument){instrument.play(Note.MIDDLE_C);}
    static void tuneAll(Instrument[] e)
    {
        for (Instrument i : e)
            tune(i);
    }

    public static void main(String[] args)
    {
        Instrument[] orchestra =
        {
            new Wind(),
            new Percussion(),
            new Stringed(),
            new Brass(),
            new Woowind()
        };
        tuneAll(orchestra);
    }
}
/*
Output:
Wind.play() MIDDLE_C
Percussion.play() MIDDLE_C
Stringed.play()MIDDLE_C
Brass.play() MIDDLE_C
Woodwind.play() MIDDLE_C
*/
```
<font color=red>当实现一个接口时，来自接口中的方法必须被定义为`public`</font>。否则，它们只有包访问权限，这样在继承时，它们的可访问权限就被降低了，这是Java编译器所不允许的。

### 默认方法default
Java 8允许接口包含默认方法和静态方法。Java 8为关键字`default`增加了一个新的用途(之前只用于`switch`语句和注解中)。<font color=red>当在接口中使用它时，任何实现接口，却没有定义方法的时候可以使用`default`创建的方法体</font>。

```java
package Interface;

interface AnInterface
{
    void firstMethod();
    void secondMethod();
}

package Interface;

public class AnImplementation implements AnInterface
{
    public void firstMethod(){System.out.println("firstMethod");}
    public void secondMethod(){System.out.println("secondMethod");}

    public static void main(String[] args)
    {
        AnInterface anInterface = new AnImplementation();
        anInterface.firstMethod();
        anInterface.secondMethod();
    }
}
```
如果我们在`AnInterface`中增加一个新方法`newMethod()`，而在`AnImplementation`中没有实现它，编译器就会报错。使用关键字`default`为`newMethod()`方法提供默认的实现，那么所有与接口有关的代码能正常工作，不受影响，而且这些代码还可以调用新的方法`newMethod()`：

```java
package Interface;

interface InterfaceWithDefault
{
    void firstMethod();
    void secondMethod();

    default void newMethod(){System.out.println("newMethod");}
}

package Interface;

public class Implementation implements InterfaceWithDefault
{
    @Override
    public void firstMethod(){System.out.println("firstMethod");}
    @Override
    public void secondMethod(){System.out.println("secondMethod");}

    public static void main(String[] args)
    {
        InterfaceWithDefault interfaceWithDefault = new Implementation();
        interfaceWithDefault.firstMethod();
        interfaceWithDefault.secondMethod();
        interfaceWithDefault.newMethod();
    }
}
/*
firstMethod
secondMethod
newMethod
 */
```

### 多继承
结合带有默认方法的接口意味着结合了多个基类中的行为。因为<font color=red>接口中仍然不允许存在属性(只有静态属性)</font>，所以属性仍然只会来自单个基类或抽象类，也就是说，<font color=red>不会存在状态的多继承</font>。

```java
package Interface;

import java.util.*;

interface One
{
    default void first(){System.out.println("first");}
}

interface Two
{
    default void second(){System.out.println("second");}
}

interface Three
{
    default void third(){System.out.println("third");}
}

class MI implements One, Two, Three{}

public class MultipleInheritance
{
    public static void main(String[] args)
    {
        MI mi = new MI();
        mi.first();
        mi.second();
        mi.third();
    }
}
```
基类方法中的方法名和参数列表要不同：`first(), second(), third()`。

```java
interface Sam1
{
    default void sam(){System.out.println("Sam1:sam");}
}

interface Sam2
{
    default void sam(int i){System.out.println(i * 2);}
}

class Sam implements Sam1, Sam2{}
// This works because the argument lists are distinct

interface Max1
{
    default void max(){System.out.println("Max1:max");}
}

interface Max2
{
    default int max(){return 47;}
}

// class Max implements Max1, Max2{}
/* Produces:
error: ‘max()' in 'Interface.Max1' clashes with 'max()' in 'Interface.Max2';
attempting to use incompatible return typ
*/
```

`Sam`类中的两个`sam()`方法有相同的方法名，但是签名不同——方法签名包括方法名和参数类型，编译器也是用它来区分方法。但是从`Max`类可看出，<font color=red>返回类型不是方法签名的一部分，因此不能用来区分方法</font>>。

为了解决这个问题，需要覆写冲突的方法：

```java
package Interface;

interface Jim1
{
    default void jim()
    {
        System.out.println("Jim1::jim");
    }
}

interface Jim2
{
    default void jim()
    {
        System.out.println("Jim2::jim");
    }
}

public class Jim implements Jim1, Jim2
{
    @Override
    public void jim()
    {
        Jim2.super.jim();  // super.jim()无法明确指向Jim1还是Jim2
    }

    public static void main(String[] args)
    {
        new Jim().jim();
    }
}
/*
Jim2::jim
*/
```

### 接口中的静态方法(模板方法设计模式)
Java 8允许在接口中添加静态方法。这么做能恰当地把工具功能置于接口中，从而操作接口，或者成为通用的工具：

```java
package Interface;

public interface Operations
{
    void execute();

    static void runOps(Operations... ops)
    {
        for (Operations op: ops)
            op.execute();
    }

    static void show(String msg){System.out.println(msg);}
}
```

这是模版方法设计模式的一个版本，`runOps()`是一个模版方法。`runOps()`使用可变参数列表，因而我们可以传入任意多的`Operation`参数并按顺序运行它们：

```java
package Interface;

class Bing implements Operations
{
    @Override
    public void execute(){Operations.show("Bing");}
}

class Crack implements Operations
{
    @Override
    public void execute(){Operations.show("Crack");}
}

class Twist implements Operations
{
    @Override
    public void execute(){Operations.show("Twist");}
}

public class Machine
{
    public static void main(String[] args)
    {
        Operations.runOps(new Bing(), new Crack(), new Twist());
    }
}
```


# 泛型
多态是一种面向对象思想的泛化机制。你可以<font color=red>将方法的参数类型设为基类，这样的方法就可以接受任何派生类作为参数</font>，包括暂时还不存在的类。

我们希望编写更通用的代码，能够适用“非特定的类型”，而不是一个具体的接口或类。

这就是泛型的概念，是`Java 5`的重大变化之一。泛型实现了参数化类型，这样你编写的组件（通常是集合）可以适用于多种类型。

## 创建泛型
促成泛型出现的最主要的动机之一是为了`创建集合类`。集合用于存放要使用到的对象。数组也是如此，不过集合比数组更加灵活，功能更丰富。

<font color=red>先指定一个类型占位符，稍后再决定具体使用什么类型</font>。要达到这个目的，需要使用`类型参数`，<font color=red>用尖括号括住，放在类名后面</font>。然后在使用这个类时，再用实际的类型替换此类型参数。在下面的例子中，`T` 就是类型参数：

```java
package Generics;

public class GenericHolder<T>
{
    private T a;

    public GenericHolder(){}

    public void setA(T a) { this.a = a; }
    public T getA() { return a; }

    public static void main(String[] args)
    {
        GenericHolder<Automobile> holder = new GenericHolder<>();
        holder.setA(new Automobile());  // 此处有类型校验
        Automobile automobile = holder.getA();  // 无需类型转换
    }
}

class Automobile{}
```

创建`GenericHolder`对象时，必须指明要持有的对象的类型，将其置于尖括号内，就像`main()`中那样使用。然后，你就<font color=red>只能在`GenericHolder`中存储该类型（或其子类，因为多态与泛型不冲突）的对象了</font>。当你调用`get()`取值时，直接就是正确的类型。

## 一个元组类库

有时<font color=red>一个方法需要能返回多个对象</font>。而`return`语句只能返回单个对象，解决方法就是创建一个对象，用它打包想要返回的多个对象。当然，可以在每次需要的时候，专门创建一个类来完成这样的工作。但是有了泛型，我们就可以一劳永逸。同时，还<font color=red>获得了编译时的类型安全</font>。

这个概念称为`元组`，它是<font color=red>将一组对象直接打包存储于单一对象中。可以从该对象读取其中的元素，但不允许向其中存储新对象</font>。

通常，元组可以具有任意长度，元组中的对象可以是不同类型的。不过，我们希望能够为每个对象指明类型，并且从元组中读取出来时，能够得到正确的类型。要处理不同长度的问题，我们需要创建多个不同的元组。下面是一个可以存储两个对象的元组：

```java
public class Tuple2<A, B> 
{
    public final A a1;
    public final B a2;
    public Tuple2(A a, B b) { a1 = a; a2 = b; }
    public String rep() { return a1 + ", " + a2; }

    @Override
    public String toString() 
    {
        return "(" + rep() + ")";
    }
}
```

构造函数传入要存储的对象。这个元组隐式地保持了其中元素的次序。

初次阅读上面的代码时，你可能认为这违反了Java编程的封装原则。`a1`和`a2`应该声明为`private`，然后提供`getFirst()`和`getSecond()`取值方法才对呀？

考虑下这样做能提供的“安全性”是什么：元组的使用程序可以读取`a1`和`a2`，然后对它们执行任何操作，但<font color=red>无法对`a1`和`a2`重新赋值。例子中的`final`可以实现同样的效果，并且更为简洁明了</font>。

我们可以利用`继承`机制实现长度更长的元组。添加更多的类型参数就行了：
```java
// Tuple3.java
public class Tuple3<A, B, C> extends Tuple2<A, B> 
{
    public final C a3;

    public Tuple3(A a, B b, C c) 
    {
        super(a, b);
        a3 = c;
    }

    @Override
    public String rep() 
    {
        return super.rep() + ", " + a3;
    }
}

// Tuple4.java
public class Tuple4<A, B, C, D> extends Tuple3<A, B, C> 
{
    public final D a4;

    public Tuple4(A a, B b, C c, D d) 
    {
        super(a, b, c);
        a4 = d;
    }

    @Override
    public String rep() 
    {
        return super.rep() + ", " + a4;
    }
}

// Tuple5.java
public class Tuple5<A, B, C, D, E> extends Tuple4<A, B, C, D> 
{
    public final E a5;

    public Tuple5(A a, B b, C c, D d, E e) 
    {
        super(a, b, c, d);
        a5 = e;
    }

    @Override
    public String rep() 
    {
        return super.rep() + ", " + a5;
    }
}

// Amphibian.java
public class Amphibian {}

// Vehicle.java
public class Vehicle {}
```

使用元组时，你只需要定义一个长度适合的元组，将其作为返回值即可。

```java
// TupleTest.java
public class TupleTest 
{
    static Tuple2<String, Integer> f() 
    {
        // 47 自动装箱为 Integer
        return new Tuple2<>("hi", 47);
    }

    static Tuple3<Amphibian, String, Integer> g() 
    {
        return new Tuple3<>(new Amphibian(), "hi", 47);
    }

    static Tuple4<Vehicle, Amphibian, String, Integer> h() 
    {
        return new Tuple4<>(new Vehicle(), new Amphibian(), "hi", 47);
    }

    static Tuple5<Vehicle, Amphibian, String, Integer, Double> k() 
    {
        return new Tuple5<>(new Vehicle(), new Amphibian(), "hi", 47, 11.1);
    }

    public static void main(String[] args) {
        Tuple2<String, Integer> ttsi = f();
        System.out.println(ttsi);
        // ttsi.a1 = "there"; // 编译错误，因为 final 不能重新赋值
        System.out.println(g());
        System.out.println(h());
        System.out.println(k());
    }
}

/* 输出：
 (hi, 47)
 (Amphibian@1540e19d, hi, 47)
 (Vehicle@7f31245a, Amphibian@6d6f6e28, hi, 47)
 (Vehicle@330bedb4, Amphibian@2503dbd3, hi, 47, 11.1)
 */
```