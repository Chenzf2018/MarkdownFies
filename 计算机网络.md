# TCP连接的建立（三次握手）

<div align=center><img src=ComputerNetworking/三次握手.gif></div>

最开始的时候客户端和服务器都是处于CLOSED状态。主动打开连接的为客户端，被动打开连接的是服务器。

在三次握手建立连接的阶段，是不会传输TCP报文段的，传输的是`传输控制块（TCB）`，传输控制块TCB(`Transmission Control Block`)<font color=red>存储了每一个连接中的一些重要信息</font>，如：TCP连接表，指向发送和接收缓存的指针，指向重传队列的指针，当前的发送和接收序号等等。

- TCP`服务器进程`先创建`传输控制块TCB`，时刻准备接受客户进程的连接请求，此时服务器就进入了`LISTEN`（监听）状态；

- TCP`客户进程`也是先创建`传输控制块TCB[SYN=1, seq=x]`，然后向服务器发出`连接请求报文`，这时报文首部中的`同部位SYN=1`，同时选择一个`初始序列号seq=x`，此时，TCP客户端进程进入了`SYN-SENT（同步已发送状态）`状态。TCP规定，<font color=red>SYN报文段（SYN=1的报文段）不能携带数据，但需要消耗掉一个序号</font>。

- TCP`服务器`收到请求报文后，如果同意连接，则构建好`TCB[SYN=1, seq=y, ACK=1, ack=x+1]`发出`确认报文`。确认报文中应该ACK=1，SYN=1，`确认号`是ack=x+1，同时也要为自己初始化一个序列号seq=y，此时，TCP服务器进程进入了`SYN-RCVD（同步收到）`状态。<font color=red>这个报文也不能携带数据，但是同样要消耗一个序号</font>。

- TCP`客户进程`收到确认后，还要向服务器给出确认。确认报文的`ACK=1`，`ack=y+1`，自己的序列号`seq=x+1`，此时，TCP连接建立，客户端进入`ESTABLISHED（已建立连接）`状态。TCP规定，<font color=red>ACK报文段可以携带数据，但是如果不携带数据则不消耗序号</font>。

- 当`服务器`收到客户端的确认后也进入`ESTABLISHED`状态，此后双方就可以开始通信了。

<div align=center><img src=ComputerNetworking/三次握手.jpg></div>

## 问题

- 为何不直接在第一次握手就带上报文段消息，非要第三次才可以带？

    因为<font color=red>TCP是要保证数据的不丢失且可靠</font>，如果在第一次就带上报文段消息，此次建立连接很有可能就会失败，那么就不能保证数据的不丢失了，在不可靠的机制上进行这种操作，换来的代价太大，每次发送报文段的资源也会增大，得不偿失；

    而第三次握手的时候，客户端已经知道服务器端准备好了，所以只要告诉服务器端自己准备好了就okay了，所以此时带上报文段信息没有任何问题。

- 可不可以只握手两次？

    不可以，主要<font color=red>防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误</font>。
    
    三次握手主要是解决这样一个常见的问题，客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了，由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。此时<font color=red>此前滞留的那一次请求连接，网络通畅了到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费</font>。

    如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。<font color=red>由于服务器收不到确认，就知道客户端并没有请求连接</font>。