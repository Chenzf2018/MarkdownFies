# TCP连接的建立（三次握手）

<div align=center><img src=ComputerNetworking/三次握手.gif></div>

最开始的时候客户端和服务器都是处于CLOSED状态。主动打开连接的为客户端，被动打开连接的是服务器。

在三次握手建立连接的阶段，是不会传输TCP报文段的，传输的是`传输控制块（TCB）`，传输控制块TCB(`Transmission Control Block`)<font color=red>存储了每一个连接中的一些重要信息</font>，如：TCP连接表，指向发送和接收缓存的指针，指向重传队列的指针，当前的发送和接收序号等等。

- TCP`服务器进程`先创建`传输控制块TCB`，时刻准备接受客户进程的连接请求，此时服务器就进入了`LISTEN`（监听）状态；

- TCP`客户进程`也是先创建`传输控制块TCB[SYN=1, seq=x]`，然后向服务器发出`连接请求报文`，这时报文首部中的`同部位SYN=1`，同时选择一个`初始序列号seq=x`，此时，TCP客户端进程进入了`SYN-SENT（同步已发送状态）`状态。TCP规定，<font color=red>SYN报文段（SYN=1的报文段）不能携带数据，但需要消耗掉一个序号</font>。

- TCP`服务器`收到请求报文后，如果同意连接，则构建好`TCB[SYN=1, seq=y, ACK=1, ack=x+1]`发出`确认报文`。确认报文中应该ACK=1，SYN=1，`确认号`是ack=x+1，同时也要为自己初始化一个序列号seq=y，此时，TCP服务器进程进入了`SYN-RCVD（同步收到）`状态。<font color=red>这个报文也不能携带数据，但是同样要消耗一个序号</font>。

- TCP`客户进程`收到确认后，还要向服务器给出确认。确认报文的`ACK=1`，`ack=y+1`，自己的序列号`seq=x+1`，此时，TCP连接建立，客户端进入`ESTABLISHED（已建立连接）`状态。TCP规定，<font color=red>ACK报文段可以携带数据，但是如果不携带数据则不消耗序号</font>。

- 当`服务器`收到客户端的确认后也进入`ESTABLISHED`状态，此后双方就可以开始通信了。

<div align=center><img src=ComputerNetworking/三次握手.jpg></div>

## 问题

- 为何不直接在第一次握手就带上报文段消息，非要第三次才可以带？

    因为<font color=red>TCP是要保证数据的不丢失且可靠</font>，如果在第一次就带上报文段消息，此次建立连接很有可能就会失败，那么就不能保证数据的不丢失了，在不可靠的机制上进行这种操作，换来的代价太大，每次发送报文段的资源也会增大，得不偿失；

    而第三次握手的时候，客户端已经知道服务器端准备好了，所以只要告诉服务器端自己准备好了就okay了，所以此时带上报文段信息没有任何问题。

- 可不可以只握手两次？

    不可以，主要<font color=red>防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误</font>。
    
    三次握手主要是解决这样一个常见的问题，客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了，由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。此时<font color=red>此前滞留的那一次请求连接，网络通畅了到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费</font>。

    如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。<font color=red>由于服务器收不到确认，就知道客户端并没有请求连接</font>。


# TCP连接的释放（四次挥手）

<div align=center><img src=ComputerNetworking/四次挥手.gif></div>

数据传输完毕后，双方都可释放连接。最开始的时候，客户端和服务器都是处于`ESTABLISHED`状态，然后客户端主动关闭，服务器被动关闭。

1.  `客户端进程`发出`连接释放报文`，<font color=red>告诉服务器端，客户端需要关闭了</font>，并且停止发送数据。释放数据报文首部，`FIN=1`，其序列号为`seq=u`（<font color=red>等于前面已经传送过来的数据的最后一个字节的序号加1</font>），此时，客户端进入`FIN-WAIT-1`（终止等待1）状态。 TCP规定，<font color=red>`FIN报文段`即使不携带数据，也要消耗一个序号</font>。

2. `服务器`收到连接释放报文，发出`确认报文`，<font color=red>告诉客户端收到了客户端要关闭的消息了</font>，`ACK=1`，`ack=u+1`，并且带上自己的序列号`seq=v`，此时，服务端就进入了`CLOSE-WAIT`（关闭等待）状态。<font color=red>TCP服务器通知高层的应用进程，进程需要关闭连接了</font>，这时候处于`半关闭状态`，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个`CLOSE-WAIT`状态持续的时间。

3. `客户端`收到服务器的确认请求后，此时，客户端就进入`FIN-WAIT-2`（终止等待2）状态，等待服务器发送`连接释放报文`（在这之前还需要接受<font color=red>服务器发送的最后的数据</font>）。

4. `服务器`将<font color=red>最后的数据</font>发送完毕后，就向客户端发送`连接释放报文`，<font color=red>告知客户端，服务器端现在要关闭了</font>,`FIN=1`，`ack=u+1`，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为`seq=w`，此时，服务器就进入了`LAST-ACK`（最后确认）状态，等待客户端的确认。

5. `客户端`收到服务器的连接释放报文后，必须`发出确认`，<font color=red>告知服务器端，客户端已经知道了你准备好关闭了</font>，`ACK=1`，`ack=w+1`，而自己的序列号是`seq=u+1`，此时，客户端就进入了`TIME-WAIT`（时间等待）状态。注意此时TCP连接还没有释放，必须经过`2*MSL`（最长报文段寿命——最长报文段传输时间）的时间后，当客户端`撤销相应的TCB`后，才进入`CLOSED`状态。
  
6. `服务器`只要收到了客户端发出的确认，立即进入`CLOSED`状态。同样，`撤销TCB`后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。


<div align=center><img src=ComputerNetworking/四次挥手.jpg></div>

## 问题

1. 为何不能三次挥手呢？
    首先如果去掉最后一次挥手，那么服务器端就不知道自己要关闭的报文有没有传输成功，可能半路上就失败了，但是此时客户端不知道，导致客户端一直在等待服务器关闭，但是此时服务器端直接就关闭了；
    
    如果中间的两次挥手合并，那是肯定不行的，因为此时服务器端可能还有很多报文未处理完，此时直接关闭肯定会对传输有很大影响。

2. 为什么客户端在收到服务器端发来的FIN包后要等2个最长报文段传输时间？
   防止最后自己发去的`ack`没传送到服务器，如果服务器没收到客户端的`ack`，肯定会选择重发一次`FIN`包，那么此时如果客户端已经关闭了，客户端就不能再发`ack`确认收到了。至于为何是2个报文段传输时间，因为刚好一去一回嘛… 2个最长报文传输时间没有FIN包发来，就说明服务器已经关闭了，客户端也就可以安心关闭了。

3. 为什么建立连接是三次握手，关闭连接确是四次挥手呢？
    建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。

    而关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送，从而导致多了一次。

4. 如果已经建立了连接，但是客户端突然出现故障了怎么办？
    TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。
